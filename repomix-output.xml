This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
cmd/api/main.go
docker-compose.yml
go.mod
internal/api/api_helper.go
internal/api/middleware_test.go
internal/api/middleware.go
internal/api/mock_test.go
internal/api/router.go
internal/api/tweet_handler_test.go
internal/api/tweet_handler.go
internal/api/user_handler_test.go
internal/api/user_handler.go
internal/configuration/configuration.go
internal/contextkeys/keys.go
internal/db/const_db.go
internal/db/main_store_test.go
internal/db/redis_session_store.go
internal/db/sql_session_store_test.go
internal/db/sql_session_store.go
internal/db/tweet_store_test.go
internal/db/tweet_store.go
internal/db/user_store_test.go
internal/db/user_store.go
internal/dto/authcontext.go
internal/dto/mapper.go
internal/dto/request.go
internal/dto/response.go
internal/errcode/error_code.go
internal/models/const.go
internal/models/session.go
internal/models/tweet.go
internal/models/user.go
internal/pkg/crypto/password.go
internal/pkg/crypto/token.go
internal/pkg/testutils/test_helper.go
internal/pkg/testutils/testdb.go
internal/pkg/utils/helper.go
internal/service/mock_service_test.go
internal/service/session_service_test.go
internal/service/session_service.go
internal/service/tweet_service_test.go
internal/service/tweet_service.go
internal/service/user_service_test.go
internal/service/user_service.go
migrations/000001_create_initial_tables.down.sql
migrations/000001_create_initial_tables.up.sql
migrations/000002_add_created_at_to_sessions.down.sql
migrations/000002_add_created_at_to_sessions.up.sql
migrations/000003_add_content_limit_to_tweets.down.sql
migrations/000003_add_content_limit_to_tweets.up.sql
migrations/000004_add_updated_at_to_tweets_table.down.sql
migrations/000004_add_updated_at_to_tweets_table.up.sql
migrations/000005_add_is_edited_to_tweets.down.sql
migrations/000005_add_is_edited_to_tweets.up.sql
README.md
scripts/init-db/init.sql
tests/main_test.go
tests/user_flow_test.go
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="internal/api/api_helper.go">
package api

import (
	"aita/internal/contextkeys"
	"aita/internal/dto"
	"aita/internal/errcode"
	"strconv"
	"strings"

	"github.com/gin-gonic/gin"
)

func extractBearerToken(header string) (string, error) {
	if header == "" {
		return "", errcode.ErrSessionNotFound
	}
	parts := strings.SplitN(header, " ", 2)
	if len(parts) == 2 && strings.EqualFold(parts[0], "bearer") {
		token := strings.TrimSpace(parts[1])
		if token == "" {
			return "", errcode.ErrSessionNotFound
		}
		return token, nil
	}
	return "", errcode.ErrSessionNotFound
}

func GetAuthContext(c *gin.Context) (*dto.AuthContext, error) {
    val, ok := c.Get(contextkeys.AuthPayloadKey)
    if !ok {
        return nil, errcode.ErrSessionNotFound
    }

    auth, ok := val.(*dto.AuthContext)
    if !ok || auth == nil {
        return nil, errcode.ErrSessionNotFound
    }

    return auth, nil
}

func GetIDParam(c *gin.Context, name string)(int64, error) {
	idStr := c.Param(name)
	id, err :=strconv.ParseInt(idStr, 10, 64)
	if err != nil || id <= 0 {
		return 0, errcode.ErrInvalidIDFormat
	}
	return id, nil
}
</file>

<file path="internal/api/tweet_handler_test.go">
package api

import (
	"aita/internal/contextkeys"
	"aita/internal/dto"
	"aita/internal/errcode"
	"aita/internal/models"
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestTweetCreate(t *testing.T) {
	gin.SetMode(gin.TestMode)
	tests := []struct {
		name           string
		requestBody    any
		setupAuth      func(c *gin.Context)
		setupMock      func(mt *mockTweetService)
		expectedStatus int
		checkResponse  func(t *testing.T, w *httptest.ResponseRecorder)
	}{
		{
			name:        "ツイート投稿成功",
			requestBody: dto.CreateTweetRequest{Content: "AITAの初投稿!"},
			setupAuth: func(c *gin.Context) {
				c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{UserID: 10})
			},
			setupMock: func(mt *mockTweetService) {
				mt.On(
					"PostTweet", 
					mock.Anything, 
					int64(10),  
					"AITAの初投稿!", 
					mock.Anything,
					).Return( &models.Tweet{
					ID:        100,
					Content:   "AITAの初投稿!",
					UserID:    10,
					CreatedAt: time.Now().UTC(),
					UpdatedAt: time.Now().UTC(),
				}, nil)
			},
			expectedStatus: http.StatusCreated,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				fmt.Println("Raw Response:", w.Body.String())
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				data := resp.Data.(map[string]any)
				assert.EqualValues(t, 100, (data["id"]))
				assert.Equal(t, "AITAの初投稿!", data["content"])
			},
		},
		{
			name:           "未認証エラー:ContextにIDがない",
			requestBody:    dto.CreateTweetRequest{Content: "Hello"},
			setupAuth:      func(c *gin.Context) {},
			setupMock:      func(mt *mockTweetService) {},
			expectedStatus: http.StatusUnauthorized,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				assert.Equal(t, "SESSION_NOT_FOUND", resp.Code)
			},
		},
		{
			name:        "JSON構文エラー",
			requestBody: `{"content": "incomplete...`,
			setupAuth: func(c *gin.Context) {
				c.Set(contextkeys.AuthPayloadKey,  &dto.AuthContext{UserID: 10})
			},
			setupMock:      func(mt *mockTweetService) {},
			expectedStatus: http.StatusBadRequest,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				assert.Equal(t, "INVALID_JSON_FORMAT", resp.Code)
			},
		},
		{
			name:        "バリデーションエラー：内容が空",
			requestBody: dto.CreateTweetRequest{Content: ""},
			setupAuth: func(c *gin.Context) {
				c.Set(contextkeys.AuthPayloadKey,  &dto.AuthContext{UserID: 10})
			},
			setupMock: func(mt *mockTweetService) {
				mt.On("PostTweet", mock.Anything, int64(10), mock.Anything).Return(nil, errcode.ErrRequiredFieldMissing)
			},
			expectedStatus: http.StatusBadRequest,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				assert.Equal(t, "REQUIRED_FIELD_MISSING", resp.Code)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mt := new(mockTweetService)
			h := NewTweetHandler(mt)
			tt.setupMock(mt)
			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)

			var buf bytes.Buffer
			if s, ok := tt.requestBody.(string); ok {
				buf.WriteString(s)
			} else {
				json.NewEncoder(&buf).Encode(tt.requestBody)
			}
			c.Request = httptest.NewRequest(http.MethodPost, "/tweets", &buf)

			tt.setupAuth(c)
			h.Create(c)
			assert.Equal(t, tt.expectedStatus, w.Code)
			if tt.checkResponse != nil {
				tt.checkResponse(t, w)
			}
		})
	}
}

func TestTweetGet(t *testing.T) {
    gin.SetMode(gin.TestMode)
    tests := []struct {
        name           string
        tweetID        string 
        setupMock      func(mt *mockTweetService)
        expectedStatus int
        checkResponse  func(t *testing.T, w *httptest.ResponseRecorder)
    }{
        {
            name:    "ツイート取得成功",
            tweetID: "100",
            setupMock: func(mt *mockTweetService) {
                mt.On("FetchTweet", mock.Anything, int64(100)).Return(&models.Tweet{
                    ID: 100, Content: "テスト取得", UserID: 10,
                }, nil)
            },
            expectedStatus: http.StatusOK,
            checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				fmt.Printf("\n--- [DEBUG] Raw JSON Response ---\n%s\n----------------------------------\n", w.Body.String())
                var resp dto.Response
				err := json.Unmarshal(w.Body.Bytes(), &resp)
				require.NoError(t, err, "JSONのパースに失敗しました")
				if w.Code != http.StatusOK {
					return 
				}
				data, ok := resp.Data.(map[string]any)
				if !ok {
					t.Fatalf("Data should be a map, but got %T: %+v", resp.Data, resp.Data)
				}
				assert.EqualValues(t, 100, data["id"])
            },
        },
        {
            name:    "エラー: 存在しないID",
            tweetID: "999",
            setupMock: func(mt *mockTweetService) {
                mt.On("FetchTweet", mock.Anything, int64(999)).Return(nil, errcode.ErrTweetNotFound)
            },
            expectedStatus: http.StatusNotFound,
            checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
                var resp dto.Response
                json.Unmarshal(w.Body.Bytes(), &resp)
                assert.Equal(t, "TWEET_NOT_FOUND", resp.Code)
            },
        },
        {
            name:           "エラー: 無効なID形式",
            tweetID:        "abc",
            setupMock:      func(mt *mockTweetService) {},
            expectedStatus: http.StatusBadRequest,
            checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
                var resp dto.Response
                json.Unmarshal(w.Body.Bytes(), &resp)
                assert.Equal(t, "INVALID_ID_FORMAT", resp.Code)
            },
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mt := new(mockTweetService)
            h := NewTweetHandler(mt)
            tt.setupMock(mt)

            w := httptest.NewRecorder()
            c, _ := gin.CreateTestContext(w)
            c.Request = httptest.NewRequest(http.MethodGet, "/", nil)
            c.Params = []gin.Param{{Key: "id", Value: tt.tweetID}}

            h.Get(c)
            assert.Equal(t, tt.expectedStatus, w.Code)
            tt.checkResponse(t, w)
        })
    }
}


func TestTweetUpdate(t *testing.T) {
    gin.SetMode(gin.TestMode)
    tests := []struct {
        name           string
        tweetID        string
        requestBody    any
        setupAuth      func(c *gin.Context)
        setupMock      func(mt *mockTweetService)
        expectedStatus int
        checkResponse  func(t *testing.T, w *httptest.ResponseRecorder)
    }{
        {
            name:        "ツイート更新成功",
            tweetID:     "100",
            requestBody: dto.UpdateTweetRequest{Content: "更新後の内容"},
            setupAuth: func(c *gin.Context) {
                c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{UserID: 10})
            },
            setupMock: func(mt *mockTweetService) {
                mt.On("EditTweet", mock.Anything, "更新後の内容", int64(100), int64(10)).
                    Return(&models.Tweet{ID: 100, Content: "更新後の内容", IsEdited: true}, true, nil)
            },
            expectedStatus: http.StatusOK,
            checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
                var resp dto.Response
                json.Unmarshal(w.Body.Bytes(), &resp)
                data := resp.Data.(map[string]any)
                assert.True(t, data["is_edited"].(bool))
            },
        },
        {
            name:        "更新成功：内容に変更なし",
            tweetID:     "100",
            requestBody: dto.UpdateTweetRequest{Content: "同じ内容"},
            setupAuth: func(c *gin.Context) {
                c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{UserID: 10})
            },
            setupMock: func(mt *mockTweetService) {
                mt.On("EditTweet", mock.Anything, "同じ内容", int64(100), int64(10)).
                    Return(&models.Tweet{ID: 100, Content: "同じ内容"}, false, nil)
            },
            expectedStatus: http.StatusOK,
            checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
                var resp dto.Response
                json.Unmarshal(w.Body.Bytes(), &resp)
                assert.Contains(t, resp.Message, "変更はありません")
            },
        },
        {
            name:        "エラー：編集期限切れ",
            tweetID:     "100",
            requestBody: dto.UpdateTweetRequest{Content: "手遅れな更新"},
            setupAuth: func(c *gin.Context) {
                c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{UserID: 10})
            },
            setupMock: func(mt *mockTweetService) {
                mt.On("EditTweet", mock.Anything, mock.Anything, mock.Anything, mock.Anything).
                    Return(nil, false, errcode.ErrEditTimeExpired)
            },
            expectedStatus: http.StatusUnprocessableEntity, 
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mt := new(mockTweetService)
            h := NewTweetHandler(mt)
            tt.setupMock(mt)

            w := httptest.NewRecorder()
            c, _ := gin.CreateTestContext(w)
            
            var buf bytes.Buffer
            json.NewEncoder(&buf).Encode(tt.requestBody)
            c.Request = httptest.NewRequest(http.MethodPatch, "/", &buf)
            c.Params = []gin.Param{{Key: "id", Value: tt.tweetID}}

            tt.setupAuth(c)
            h.Update(c)
            assert.Equal(t, tt.expectedStatus, w.Code)
            if tt.checkResponse != nil {
                tt.checkResponse(t, w)
            }
        })
    }
}

func TestTweetDelete(t *testing.T) {
    gin.SetMode(gin.TestMode)
    tests := []struct {
        name           string
        tweetID        string
        setupAuth      func(c *gin.Context)
        setupMock      func(mt *mockTweetService)
        expectedStatus int
    }{
        {
            name:    "削除成功",
            tweetID: "100",
            setupAuth: func(c *gin.Context) {
                c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{UserID: 10})
            },
            setupMock: func(mt *mockTweetService) {
                mt.On("RemoveTweet", mock.Anything, int64(100), int64(10)).Return(nil)
            },
            expectedStatus: http.StatusOK,
        },
        {
            name:    "エラー：他人のツイートを削除しようとした",
            tweetID: "100",
            setupAuth: func(c *gin.Context) {
                c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{UserID: 99}) 
            },
            setupMock: func(mt *mockTweetService) {
                mt.On("RemoveTweet", mock.Anything, mock.Anything, mock.Anything).
                    Return(errcode.ErrForbidden)
            },
            expectedStatus: http.StatusForbidden,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mt := new(mockTweetService)
            h := NewTweetHandler(mt)
            tt.setupMock(mt)

            w := httptest.NewRecorder()
            c, _ := gin.CreateTestContext(w)
            c.Request = httptest.NewRequest(http.MethodDelete, "/", nil)
            c.Params = []gin.Param{{Key: "id", Value: tt.tweetID}}

            tt.setupAuth(c)
            h.Delete(c)
            assert.Equal(t, tt.expectedStatus, w.Code)
        })
    }
}
</file>

<file path="internal/configuration/configuration.go">
package configuration

import (
	"log"
	"os"
	"path/filepath"
	"runtime"

	"github.com/joho/godotenv"
)

var projectRoot string

// パスの自動検知
func init() {
	// 環境変数のチェック（本番環境のカスタマイズ用）
	projectRoot = os.Getenv("AITA_PROJECT_ROOT")
	if projectRoot != "" {
		return
	}

	//カレントディレクトリに .env があるか確認（バイナリと設定ファイルが同階層にある場合）
	if _, err := os.Stat(".env"); err == nil {
		cwd, _ := os.Getwd()
		projectRoot = cwd
		return
	}

	//開発環境用フォールバック（runtime を使用してソースコードのパスを取得）
	_, b, _, _ := runtime.Caller(0)
	projectRoot = filepath.Join(filepath.Dir(b), "..", "..")
}

func GetPath(relPath string) string {
	return filepath.Join(projectRoot, relPath)
}

type Config struct{
	DBConnStr        string
	ServerAddress    string
	AppEnv           string
}

func LoadConfig() *Config{
	envPath := GetPath(".env")
	if err := godotenv.Load(envPath); err != nil {
		log.Printf("エラー :.envが見つかりません")
	}

	appEnv := os.Getenv("APP_ENV")
	if 	appEnv == "" {
		appEnv = "development"
	}

	var dbURL string
	if appEnv== "test" {
        dbURL = os.Getenv("DB_TEST_URL")
		log.Println("DB_TEST_URLに切り替えます")
    } else {
		dbURL = os.Getenv("DB_URL")
	}

	if dbURL == "" {
		log.Fatal("エラー：環境変数 DB_URL が設定されていません")
	}
	return &Config{
		DBConnStr:     dbURL,
		ServerAddress: ":8080",
		AppEnv:        appEnv,
	}
}
</file>

<file path="internal/dto/authcontext.go">
package dto

type AuthContext struct {
    UserID    int64
    SessionID int64
    Role      string
}
</file>

<file path="internal/dto/mapper.go">
package dto

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"encoding/json"
	"errors"
	"io"

	"github.com/go-playground/validator/v10"
)


func NewUserResponse(user *models.User) *UserResponse {
	if user == nil {
        return nil
    }
	return &UserResponse{
		ID:        user.ID,
		Username:  user.Username,
		Email:     user.Email,
		CreatedAt: user.CreatedAt,
	}
}

func NewTweetResponse(tweet *models.Tweet) TweetResponse {
	return TweetResponse{
		ID: 		tweet.ID,
		UserID:     tweet.UserID,
		Content:    tweet.Content,
		ImageURL:   tweet.ImageURL,
		CreatedAt:  tweet.CreatedAt,
		UpdatedAt:  tweet.UpdatedAt,
		IsEdited:   tweet.IsEdited,
	}
}

func Fail(err error) Response {
	return Response{
		Error: err.Error(),
		Code:  GetBusinessCode(err),
	}
}

func Success(data any) Response {
	return Response{
		Data: data,
		Code: "SUCCESS",
	}
}

func SuccessMsg(msg string) Response {
	return Response{
		Message: msg,
		Code: "SUCCESS",
	}
}

func SuccessWithMeta(data any, meta any) Response {
	return Response{
		Data: data,
		Meta: meta,
		Code: "SUCCESS",
	}
}

func FilterBindError(err error) error {
	if err == nil {
		return nil
	}

	if errors.Is(err, io.EOF) || errors.Is(err, io.ErrUnexpectedEOF) {
		return errcode.ErrInvalidJSON
	}

	var se *json.SyntaxError
	var ute *json.UnmarshalTypeError
	if errors.As(err, &se) || errors.As(err, &ute) {
		return errcode.ErrInvalidJSON
	}

	var ve validator.ValidationErrors
	if errors.As(err, &ve) {
		return errcode.ErrInvalidRequestFormat
	}

	return errcode.ErrInvalidJSON
}

func GetStatusCode(err error) int {
	if err == nil {
		return 200
	}

	if errors.Is(err, errcode.ErrInvalidCredentials) ||
		errors.Is(err, errcode.ErrSessionExpired) ||
		errors.Is(err, errcode.ErrSessionNotFound) {
		return 401
	}

	if errors.Is(err, errcode.ErrForbidden) {
		return 403
	}

	if errors.Is(err, errcode.ErrUserNotFound) ||
		errors.Is(err, errcode.ErrTweetNotFound) {
		return 404
	}

	if errors.Is(err, errcode.ErrUsernameConflict) ||
		errors.Is(err, errcode.ErrEmailConflict) ||
		errors.Is(err, errcode.ErrTokenConflict) {
		return 409
	}

	if errors.Is(err, errcode.ErrEditTimeExpired) {
		return 422
	}
	if errors.Is(err, errcode.ErrRequiredFieldMissing) ||
		errors.Is(err, errcode.ErrInvalidUsernameFormat) ||
		errors.Is(err, errcode.ErrInvalidEmailFormat) ||
		errors.Is(err, errcode.ErrInvalidPasswordFormat) ||
		errors.Is(err, errcode.ErrInvalidUserID) ||
		errors.Is(err, errcode.ErrInvalidSessionID) ||
		errors.Is(err, errcode.ErrInvalidTokenFormat) ||
		errors.Is(err, errcode.ErrInvalidTweetID) ||
		errors.Is(err, errcode.ErrInvalidUrlFormat) ||
		errors.Is(err, errcode.ErrInvalidContentFormat) ||
		errors.Is(err, errcode.ErrValueTooLong) ||
		errors.Is(err, errcode.ErrInvalidJSON) ||
		errors.Is(err, errcode.ErrInvalidIDFormat ) ||
		errors.Is(err, errcode.ErrInvalidRequestFormat) {
		return 400
	}

	return 500
}

func GetBusinessCode(err error) string {
	if err == nil {
		return ""
	}

	switch {
	case errors.Is(err, errcode.ErrInvalidJSON):
		return "INVALID_JSON_FORMAT"
	case errors.Is(err, errcode.ErrInvalidIDFormat ):
		return "INVALID_ID_FORMAT"
	case errors.Is(err, errcode.ErrInvalidRequestFormat):
		return "INVALID_REQUEST_FORMAT"
	case errors.Is(err, errcode.ErrRequiredFieldMissing):
		return "REQUIRED_FIELD_MISSING"
	case errors.Is(err, errcode.ErrInvalidUsernameFormat):
		return "INVALID_USERNAME_FORMAT"
	case errors.Is(err, errcode.ErrInvalidEmailFormat):
		return "INVALID_EMAIL_FORMAT"
	case errors.Is(err, errcode.ErrInvalidTokenFormat):
		return "INVALID_TOKEN_FORMAT"
	case errors.Is(err, errcode.ErrInvalidPasswordFormat):
		return "INVALID_PASSWORD_FORMAT"
	case errors.Is(err, errcode.ErrInvalidUserID):
		return "INVALID_USER_ID"
	case errors.Is(err, errcode.ErrInvalidSessionID):
		return "INVALID_SESSION_ID"
	case errors.Is(err, errcode.ErrInvalidTweetID):
		return "INVALID_TWEET_ID"
	case errors.Is(err, errcode.ErrInvalidUrlFormat):
		return "INVALID_URL_FORMAT"
	case errors.Is(err, errcode.ErrInvalidContentFormat):
		return "INVALID_CONTENT_FORMAT"
	case errors.Is(err, errcode.ErrValueTooLong):
		return "VALUE_TOO_LONG"

	case errors.Is(err, errcode.ErrInvalidCredentials):
		return "INVALID_CREDENTIALS"
	case errors.Is(err, errcode.ErrSessionExpired):
		return "SESSION_EXPIRED"
	case errors.Is(err, errcode.ErrSessionNotFound):
		return "SESSION_NOT_FOUND"

	case errors.Is(err, errcode.ErrUserNotFound):
		return "USER_NOT_FOUND"
	case errors.Is(err, errcode.ErrTweetNotFound):
		return "TWEET_NOT_FOUND"
	case errors.Is(err, errcode.ErrUsernameConflict):
		return "USERNAME_CONFLICT"
	case errors.Is(err, errcode.ErrEmailConflict):
		return "EMAIL_CONFLICT"
	case errors.Is(err, errcode.ErrTokenConflict):
		return "TOKEN_CONFLICT"
	case errors.Is(err, errcode.ErrForbidden):
		return "FORBIDDEN_ACCESS"

	case errors.Is(err, errcode.ErrEditTimeExpired):
		return "EDIT_TIME_EXPIRED"

	default:
		return "INTERNAL_SERVER_ERROR"
	}
}
</file>

<file path="internal/dto/request.go">
package dto

import (
	"aita/internal/errcode"
	"aita/internal/pkg/utils"
	"strings"
	"unicode/utf8"
)

type SignupRequest struct {
	Username     string 	   `json:"username" binding:"required,min=4,max=50" `
	Email        string        `json:"email" binding:"required,email"`
	Password     string        `json:"password" binding:"required,min=8,max=72"`
}

type LoginRequest struct {
	Email    	 string        `json:"email" binding:"required,email"`
	Password 	 string         `json:"password" binding:"required,min=8,max=72"`
}

type CreateTweetRequest struct {
	Content		 string        `json:"content" binding:"max=1000"`
	ImageURL    *string        `json:"image_url" binding:"omitempty,url"`
}

type UpdateTweetRequest struct {
    Content      string        `json:"content" binding:"required,max=1000"`
}


func (r *SignupRequest) Validate() error {
	r.Username =strings.TrimSpace(r.Username)
	r.Email = strings.TrimSpace(r.Email)
	r.Password  = strings.TrimSpace(r.Password )
	if r.Username == "" || r.Email == "" || r.Password == "" {
		return errcode.ErrRequiredFieldMissing
	}
	if len(r.Username) < 4 || len(r.Username) > 50 {
		return errcode.ErrInvalidUsernameFormat
	}
	if len(r.Password) < 8 || len(r.Password) > 72 {
		return errcode.ErrInvalidPasswordFormat
	}
	if !utils.IsValidEmail(r.Email) || len(r.Email) > 255 {
		return errcode.ErrInvalidEmailFormat
	}	

	return nil
}


func (r *LoginRequest) Validate() error {
	r.Email = strings.TrimSpace(r.Email)
	r.Password = strings.TrimSpace(r.Password)
	if r.Email == "" || r.Password == "" {
		return errcode.ErrRequiredFieldMissing
	}
	if len(r.Password) < 8 || len(r.Password) > 72 {
		return errcode.ErrInvalidPasswordFormat
	}
	if !utils.IsValidEmail(r.Email) || len(r.Email) > 255 {
		return errcode.ErrInvalidEmailFormat
	}
	return nil
}

func (r *CreateTweetRequest) Validate() error {
    r.Content = strings.TrimSpace(r.Content)
    if r.Content == "" {
        return errcode.ErrRequiredFieldMissing
    }
	if r.ImageURL != nil {
        trimmed := strings.TrimSpace(*r.ImageURL)
        if trimmed == "" {
            r.ImageURL = nil
        } else {
            *r.ImageURL = trimmed
        }
    }
   	if utf8.RuneCountInString(r.Content) > 1000 {
		return errcode.ErrInvalidContentFormat
	}
    return nil
}

func (r *UpdateTweetRequest) Validate() error {
    r.Content = strings.TrimSpace(r.Content)
    if r.Content == "" {
        return errcode.ErrRequiredFieldMissing
    }
    if utf8.RuneCountInString(r.Content) > 1000 {
        return errcode.ErrInvalidContentFormat
    }
    return nil
}
</file>

<file path="internal/dto/response.go">
package dto

import "time"

type Response struct {
	Data    any    `json:"data,omitempty"`
	Message string `json:"message,omitempty"`
	Error   string `json:"error,omitempty"`
	Code    string `json:"code,omitempty"`
	Meta    any    `json:"meta,omitempty"`
}

type UserResponse struct {
	ID        int64     `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	CreatedAt time.Time `json:"created_at"`
}

type LoginResponse struct {
	SessionToken string       `json:"session_token"`
	User         *UserResponse `json:"user"`
}

type TweetResponse struct{
	ID            int64        `json:"id"`
	UserID        int64		   `json:"user_id"`
	Content       string       `json:"content"`
	ImageURL     *string       `json:"image_url"`
	CreatedAt     time.Time    `json:"created_at"` 
	UpdatedAt     time.Time    `json:"updated_at"`
	IsEdited      bool         `json:"is_edited"`
}
</file>

<file path="internal/errcode/error_code.go">
package errcode

import "errors"

var (
	ErrInvalidRequestFormat  = errors.New("リクエスト形式が正しくありません")
	ErrInvalidJSON           = errors.New("JSONの構文が正しくありません")
	ErrInvalidIDFormat       = errors.New("IDの形式が正しくありません")
	ErrEditTimeExpired       = errors.New("投稿から10分以上経過したツイートは編集できません")
	ErrForbidden             = errors.New("指定された操作を行う権限がありません")
	ErrRequiredFieldMissing  = errors.New("必要な項目が不足しています")
	ErrInvalidUsernameFormat = errors.New("ユーザーネームの形式が正しくありません(4〜50文字)")
	ErrInvalidEmailFormat    = errors.New("有効なメールアドレスを入力してください(最大255文字)")
	ErrInvalidPasswordFormat = errors.New("パスワードの形式が正しくありません(8〜72文字)")
	ErrInvalidUserID         = errors.New("無効なユーザーIDです")
	ErrInvalidSessionID      = errors.New("無効なセッションIDです")
	ErrInvalidTokenFormat    = errors.New("有効トークンを入力してください(最大255文字)")
	ErrInvalidUrlFormat      = errors.New("Will be written")
	ErrInvalidTweetID        = errors.New("無効なツイートIDです")
	ErrInvalidContentFormat  = errors.New("contentの形式が正しくありません(最大1000文字)")

	ErrValueTooLong = errors.New("入力内容が長すぎます")

	ErrUserNotFound    = errors.New("ユーザーデータが存在しません")
	ErrSessionNotFound = errors.New("セッションが見つかりません")
	ErrTweetNotFound   = errors.New("ツイートが見つかりません")

	ErrSessionExpired   = errors.New("セッションが期限切れです")
	ErrUsernameConflict = errors.New("ユーザーネームは既に使用されています")
	ErrEmailConflict    = errors.New("メールのアドレスは既に使用されています")
	ErrTokenConflict    = errors.New("トークンは既に存在します")

	ErrInvalidCredentials = errors.New("メールアドレスまたはパスワードが正しくありません")
)
</file>

<file path="internal/models/const.go">
package models

import "time"

const (
	MaxSessionLife		= 7 * 24 * time.Hour
	SessionDuration     = 24 * time.Hour
	editWindow          = 10 * time.Minute
)
</file>

<file path="migrations/000004_add_updated_at_to_tweets_table.down.sql">
DROP TRIGGER IF EXISTS update_tweet_modtime ON tweets;

DROP FUNCTION IF EXISTS update_modified_column();

ALTER TABLE tweets DROP COLUMN IF EXISTS updated_at;
</file>

<file path="migrations/000004_add_updated_at_to_tweets_table.up.sql">
ALTER TABLE tweets 

ADD COLUMN updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_tweet_modtime
    BEFORE UPDATE ON tweets
    FOR EACH ROW
    EXECUTE FUNCTION update_modified_column();
</file>

<file path="migrations/000005_add_is_edited_to_tweets.down.sql">
ALTER TABLE tweets DROP COLUMN is_edited;
</file>

<file path="migrations/000005_add_is_edited_to_tweets.up.sql">
ALTER TABLE tweets ADD COLUMN is_edited BOOLEAN DEFAULT FALSE;
</file>

<file path="internal/contextkeys/keys.go">
package contextkeys

type contextKeys string

const(
	AuthPayloadKey = "authorization_user_id"
)
</file>

<file path="internal/db/const_db.go">
package db

const (
	errCodeStringDataRightTruncation = "22001"
	errCodeForeignKeyViolation       = "23503"
	errCodeUniqueViolation           = "23505"
	constraintSessionUserFK          = "sessions_user_id_fkey"
	constraintTokenHashUnique        = "sessions_token_hash_key"
	constraintTweetUserFK            = "tweets_user_id_fkey"
	constraintUsernameK              = "users_username_key"
	constraintUseremailK             = "users_email_key"
	constraintTokenhashK             = "sessions_token_hash_key"
)
</file>

<file path="internal/db/redis_session_store.go">
package db
</file>

<file path="internal/db/sql_session_store_test.go">
package db

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"aita/internal/pkg/testutils"
	"context"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCreateSession(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "token_test_user",
		Email:        "token_test@example.com",
		PasswordHash: "hashed_password",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	t.Run("正常にセッションできること", func(t *testing.T) {
		mockHash := "mock_hash_value_123"
		expiresAt := time.Now().Add(24 * time.Hour).UTC()
		sessionToCreate := &models.Session{
			UserID:    createdUser.ID,
			TokenHash: mockHash,
			ExpiresAt: expiresAt,
		}
		createdSession, err := testSessionStore.Create(ctx, sessionToCreate)

		require.NoError(t, err, "Sessionの作成に失敗してはいけません")
		require.NotNil(t, createdSession)
		assert.Equal(t, createdUser.ID, createdSession.UserID)
		assert.Equal(t, mockHash, createdSession.TokenHash)
		assert.WithinDuration(t, expiresAt, createdSession.ExpiresAt, time.Second)
		assert.NotZero(t, createdSession.CreatedAt)
	})

}

func TestCreateSessionWhileErr(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "token_test_user",
		Email:        "token_test@example.com",
		PasswordHash: "hashed_password",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	t.Run("23503: ユーザーがない", func(t *testing.T) {
		mockHash := "mock_hash_value_123"
		expiresAt := time.Now().Add(24 * time.Hour).UTC()
		sessionToCreate := &models.Session{
			UserID:    int64(999999),
			TokenHash: mockHash,
			ExpiresAt: expiresAt,
		}
		createdSession, err := testSessionStore.Create(ctx, sessionToCreate)

		assert.ErrorIs(t, err, errcode.ErrUserNotFound)
		assert.Nil(t, createdSession)
	})

	t.Run("23505: トークンハッシュの重複 (Unique Violation)", func(t *testing.T) {
		mockHash := "duplicate_hash"
		expiresAt := time.Now().Add(24 * time.Hour).UTC()
		initSession := &models.Session{
			UserID:    createdUser.ID,
			TokenHash: mockHash,
			ExpiresAt: expiresAt,
		}
		_, err := testSessionStore.Create(ctx, initSession)
		require.NoError(t, err)

		newSession := &models.Session{
			UserID:    createdUser.ID,
			TokenHash: mockHash,
			ExpiresAt: expiresAt,
		}
		createdSession, err := testSessionStore.Create(ctx, newSession)

		assert.ErrorIs(t, err, errcode.ErrTokenConflict)
		assert.Nil(t, createdSession)
	})

	t.Run("22001: tokenhash列長超過", func(t *testing.T) {
		mockHash := strings.Repeat("a", 256)
		expiresAt := time.Now().Add(24 * time.Hour).UTC()
		sessionToCreate := &models.Session{
			UserID:    createdUser.ID,
			TokenHash: mockHash,
			ExpiresAt: expiresAt,
		}
		createdSession, err := testSessionStore.Create(ctx, sessionToCreate)

		assert.ErrorIs(t, err, errcode.ErrValueTooLong)
		assert.Nil(t, createdSession)
	})

	t.Run("データベース切断時の時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, err := testutils.OpenDB(testContext.DSN)
		require.NoError(t, err)

		tempSessionStore := NewPostgresSessionStore(tempDB)
		tempDB.Close()

		mockHash := "mock_hash_value_123"
		expiresAt := time.Now().Add(24 * time.Hour).UTC()
		sessionToCreate := &models.Session{
			UserID:    createdUser.ID,
			TokenHash: mockHash,
			ExpiresAt: expiresAt,
		}
		createdUser, err := tempSessionStore.Create(ctx, sessionToCreate)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "セッションの生成に失敗しました")
		t.Logf("エラーは: %v\n", err)
		assert.Nil(t, createdUser)
	})
}

func TestGetByHash(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	newUser := &models.User{
		Username:     "test_get_token",
		Email:        "get_token@example.com",
		PasswordHash: "hash",
	}
	createdUser, err := testUserStore.Create(ctx, newUser)
	require.NoError(t, err)

	targetHash := "target_secret_hash"
	initSession := &models.Session{
		UserID:    createdUser.ID,
		TokenHash: targetHash,
		ExpiresAt: time.Now().Add(24 * time.Hour).UTC(),
	}
	createdSession, _ := testSessionStore.Create(ctx, initSession)
	require.NoError(t, err)

	t.Run("存在するHashで取得", func(t *testing.T) {
		foundSession, err := testSessionStore.GetByHash(ctx, targetHash)

		require.NoError(t, err)
		require.NotNil(t, foundSession)
		assert.Equal(t, createdSession.ID, foundSession.ID)
		assert.Equal(t, createdSession.TokenHash, foundSession.TokenHash)
		assert.Equal(t, createdSession.UserID, foundSession.UserID)
		assert.Equal(t, createdSession.ExpiresAt, foundSession.ExpiresAt)
		assert.Equal(t, createdSession.CreatedAt, foundSession.CreatedAt)
	})
}

func TestGetByHashWhileErr(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	newUser := &models.User{
		Username:     "test_get_token",
		Email:        "get_token@example.com",
		PasswordHash: "hash",
	}
	createdUser, err := testUserStore.Create(ctx, newUser)
	require.NoError(t, err)

	targetHash := "target_secret_hash"
	initSession := &models.Session{
		UserID:    createdUser.ID,
		TokenHash: targetHash,
		ExpiresAt: time.Now().Add(24 * time.Hour).UTC(),
	}
	_, err = testSessionStore.Create(ctx, initSession)
	require.NoError(t, err)

	t.Run("tokenhashが存在しない", func(t *testing.T) {
		wrongHash := "wrong_test_toke "
		foundSession, err := testSessionStore.GetByHash(ctx, wrongHash)

		assert.ErrorIs(t, err, errcode.ErrSessionNotFound)
		assert.Nil(t, foundSession)
	})

	t.Run("データベース切断時の時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, err := testutils.OpenDB(testContext.DSN)
		require.NoError(t, err)

		tempSessionStore := NewPostgresSessionStore(tempDB)
		tempDB.Close()

		unfoundSession, err := tempSessionStore.GetByHash(ctx, targetHash)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "セッション取得に失敗")
		t.Logf("エラーは: %v\n", err)
		assert.Nil(t, unfoundSession)
	})
}

func TestUpdateExpiredAt(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "update_test_user",
		Email:        "update_test@example.com",
		PasswordHash: "hashed_password",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	initialSession := &models.Session{
		UserID:    createdUser.ID,
		TokenHash: "initial_hash",
		ExpiresAt: time.Now().Add(24 * time.Hour).UTC(),
	}
	createdSession, err := testSessionStore.Create(ctx, initialSession)
	require.NoError(t, err)

	t.Run("正常に有効期限を更新できること", func(t *testing.T) {
		newExpiry := time.Now().Add(48 * time.Hour).UTC()

		err := testSessionStore.UpdateExpiresAt(ctx, newExpiry, createdSession.ID)

		assert.NoError(t, err)

		updatedSession, err := testSessionStore.GetByHash(ctx, "initial_hash")
		require.NoError(t, err)
		assert.WithinDuration(t, newExpiry, updatedSession.ExpiresAt, time.Second)
	})
}

func TestUpdateExpiredAtWhileErr(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "update_test_user",
		Email:        "update_test@example.com",
		PasswordHash: "hashed_password",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	initialSession := &models.Session{
		UserID:    createdUser.ID,
		TokenHash: "initial_hash",
		ExpiresAt: time.Now().Add(24 * time.Hour).UTC(),
	}
	createdSession, err := testSessionStore.Create(ctx, initialSession)
	require.NoError(t, err)

	t.Run("存在しないIDを指定した場合、ErrSessionNotFoundを返すこと", func(t *testing.T) {
		nonExistentID := int64(999999)
		newExpiry := time.Now().Add(24 * time.Hour).UTC()

		err := testSessionStore.UpdateExpiresAt(ctx, newExpiry, nonExistentID)
		assert.ErrorIs(t, err, errcode.ErrSessionNotFound)
	})

	t.Run("データベース切断時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, _ := testutils.OpenDB(testContext.DSN)
		tempStore := NewPostgresSessionStore(tempDB)
		tempDB.Close()

		err := tempStore.UpdateExpiresAt(ctx, time.Now(), createdSession.ID)

		require.Error(t, err)
		assert.Contains(t, err.Error(), "セッション期限の更新に失敗しました")
		t.Logf("期待通りキャッチされたエラー: %v", err)
	})
}

func TestDeleteBySessionID(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "update_test_user",
		Email:        "update_test@example.com",
		PasswordHash: "hashed_password",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)
	hash := "initial_hash"
	initialSession := &models.Session{
		UserID:    createdUser.ID,
		TokenHash: hash,
		ExpiresAt: time.Now().Add(24 * time.Hour).UTC(),
	}
	createdSession, err := testSessionStore.Create(ctx, initialSession)
	require.NoError(t, err)
	require.NotNil(t, createdSession)

	t.Run("正常にハッシュで削除できること", func(t *testing.T) {
		err = testSessionStore.DeleteBySessionID(ctx, createdSession.ID)
		require.NoError(t, err)
		test, err := testSessionStore.GetByHash(ctx, hash)
		require.ErrorIs(t, err, errcode.ErrSessionNotFound)
		require.Nil(t, test)
	})
	t.Run("データベース切断時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, _ := testutils.OpenDB(testContext.DSN)
		tempStore := NewPostgresSessionStore(tempDB)
		tempDB.Close()

		err := tempStore.DeleteBySessionID(ctx, createdSession.ID)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "セッションの削除に失敗しました")
		t.Logf("期待通りキャッチされたエラー: %v", err)
	})

	t.Run("存在しないIDを指定した場合、ErrSessionNotFoundを返すこと", func(t *testing.T) {
		wrongID:= int64(999)
		err := testSessionStore.DeleteBySessionID(ctx, wrongID)
		assert.ErrorIs(t, err, errcode.ErrSessionNotFound)
	})
}

func TestDeleteAllByUserID(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()
	initUser := &models.User{
		Username:     "update_test_user",
		Email:        "update_test@example.com",
		PasswordHash: "hashed_password",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)
	hashList := []string{"token_hash_1", "token_hash_2", "token_hash_3"}
	for i := range hashList {
		initSession := &models.Session{
			UserID:    createdUser.ID,
			TokenHash: hashList[i],
			ExpiresAt: time.Now().Add(24 * time.Hour).UTC(),
		}
		createdSession, err := testSessionStore.Create(ctx, initSession)
		require.NoError(t, err)
		require.NotNil(t, createdSession)
	}

	t.Run("正常にユーザーIDで削除できること", func(t *testing.T) {
		err = testSessionStore.DeleteAllByUserID(ctx, createdUser.ID)
		require.NoError(t, err)
		for i := range hashList {
			createdSession, err := testSessionStore.GetByHash(ctx, hashList[i])
			require.ErrorIs(t, err, errcode.ErrSessionNotFound)
			require.Nil(t, createdSession)
		}
	})

	t.Run("データベース切断時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, _ := testutils.OpenDB(testContext.DSN)
		tempStore := NewPostgresSessionStore(tempDB)
		tempDB.Close()

		err := tempStore.DeleteAllByUserID(ctx, createdUser.ID)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "ユーザーの全セッション削除に失敗しました")
		t.Logf("期待通りキャッチされたエラー: %v", err)
	})
}
</file>

<file path="internal/db/sql_session_store.go">
package db

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

type postgresSessionStore struct {
	database *sqlx.DB
}

func NewPostgresSessionStore(db *sqlx.DB) *postgresSessionStore {
	return &postgresSessionStore{database: db}
}

func (s *postgresSessionStore) Create(ctx context.Context, session *models.Session) (*models.Session, error) {
	query := `INSERT INTO sessions(user_id, token_hash, expires_at) 
              VALUES ($1, $2, $3)
              RETURNING id, user_id, token_hash, expires_at, created_at`

	var newSession models.Session
	err := s.database.QueryRowContext(
		ctx,
		query,
		session.UserID,
		session.TokenHash,
		session.ExpiresAt,
	).Scan(
		&newSession.ID,
		&newSession.UserID,
		&newSession.TokenHash,
		&newSession.ExpiresAt,
		&newSession.CreatedAt,
	)

	if err != nil {
		var pqErr *pq.Error
		if errors.As(err, &pqErr) {
			switch pqErr.Code {
			case errCodeForeignKeyViolation:
				if pqErr.Constraint == constraintSessionUserFK {
					return nil, errcode.ErrUserNotFound
				}
			case errCodeUniqueViolation:
				if pqErr.Constraint == constraintTokenHashUnique {
					return nil, errcode.ErrTokenConflict
				}
			case errCodeStringDataRightTruncation:
				return nil, errcode.ErrValueTooLong
			}
		}
		return nil, fmt.Errorf("セッションの生成に失敗しました: %w", err)
	}

	newSession.ExpiresAt = newSession.ExpiresAt.UTC()
	newSession.CreatedAt = newSession.CreatedAt.UTC()
	return &newSession, nil
}

func (s *postgresSessionStore) GetByHash(ctx context.Context, tokenHash string) (*models.Session, error) {
	query := `SELECT id, user_id, token_hash, expires_at, created_at FROM sessions WHERE token_hash = $1`

	var newSession models.Session
	err := s.database.GetContext(ctx, &newSession, query, tokenHash)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, errcode.ErrSessionNotFound
		}
		return nil, fmt.Errorf("tokenhashによるセッション取得に失敗しました: %w", err)
	}

	newSession.ExpiresAt = newSession.ExpiresAt.UTC()
	newSession.CreatedAt = newSession.CreatedAt.UTC()
	return &newSession, nil
}

func (s *postgresSessionStore) UpdateExpiresAt(ctx context.Context, expiresAt time.Time, id int64) error {
	query := `UPDATE sessions SET expires_at = $1 WHERE id = $2`

	result, err := s.database.ExecContext(ctx, query, expiresAt, id)

	if err != nil {
		return fmt.Errorf("セッション期限の更新に失敗しました: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("影響を受けた行数の取得に失敗しました: %w", err)
	}

	if rows == 0 {
		return errcode.ErrSessionNotFound
	}

	return nil
}

func (s *postgresSessionStore) DeleteBySessionID(ctx context.Context, sessionID int64) error {
	query := `DELETE FROM sessions WHERE id = $1`
	result, err := s.database.ExecContext(ctx, query, sessionID)
	if err != nil {
		return fmt.Errorf("セッションの削除に失敗しました: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("影響を受けた行数の取得に失敗しました: %w", err)
	}
	if rows == 0 {
		return errcode.ErrSessionNotFound
	}
	return nil
}

func (s *postgresSessionStore) DeleteAllByUserID(ctx context.Context, userID int64) error {
	query := ` DELETE FROM sessions WHERE user_id = $1`
	_, err := s.database.ExecContext(ctx, query, userID)
	if err != nil {
		return fmt.Errorf("ユーザーの全セッション削除に失敗しました: %w", err)
	}

	return nil
}
</file>

<file path="internal/pkg/crypto/password.go">
package crypto

import "golang.org/x/crypto/bcrypt"



type bcryptHasher struct {
	cost int
}

func NewBcryptHasher(c int) *bcryptHasher {
	return &bcryptHasher{cost: c}
}

func (b *bcryptHasher) Generate(password string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), b.cost)
	if err != nil{
		return "", err
	}
	return string(hash), nil
}

func (b *bcryptHasher) Compare(hashedPassword, password string) error {
	return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}
</file>

<file path="internal/pkg/crypto/token.go">
package crypto

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
)

type tokenManager struct{}

func NewTokenManager() *tokenManager {
	return &tokenManager{}
}

func (m *tokenManager) Generate(length int) (string, error) {
	b := make([]byte, length)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	return base64.URLEncoding.EncodeToString(b), nil
}

func (m *tokenManager) Hash(token string) string {
	hash := sha256.Sum256([]byte(token))
	return base64.URLEncoding.EncodeToString(hash[:])
}
</file>

<file path="internal/pkg/testutils/test_helper.go">
package testutils

import "github.com/stretchr/testify/mock"

func SafeGet[T any](args mock.Arguments, index int) *T {
	val := args.Get(index)
	if val == nil {
		return nil
	}
	return val.(*T)
}
</file>

<file path="internal/service/user_service_test.go">
package service

import (
	"aita/internal/dto"
	"aita/internal/errcode"
	"aita/internal/models"
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestRegister(t *testing.T) {
    gin.SetMode(gin.TestMode)
    tests := map[string]struct {
        inputBody *dto.SignupRequest
        setupMock func(mu *mockUserStore, mh *mockBcryptHasher)
        wantedErr error
        errMsg    string
    }{
        "登録成功": {
            inputBody: &dto.SignupRequest{
                Username: "mock_user",
                Email:    "mock@example.com",
                Password: "password101",
            },
            setupMock: func(mu *mockUserStore, mh *mockBcryptHasher) {
                mh.On("Generate", "password101").Return("mock_hash", nil)
                mu.On("Create", mock.Anything, mock.MatchedBy(func(user *models.User) bool {
                    return user.Username == "mock_user" && user.Email == "mock@example.com" && user.PasswordHash == "mock_hash"
                })).Return(&models.User{
                    ID:           1,
                    Username:     "mock_user",
                    Email:        "mock@example.com",
                    PasswordHash: "mock_hash",
                    CreatedAt:    time.Now().UTC(),
                }, nil)
            },
            wantedErr: nil,
        },
        "必須項目が不足": {
            inputBody: &dto.SignupRequest{
                Username: "mock_user",
                Email:    "mock@example.com",
                Password: "", 
            },
            setupMock: func(mu *mockUserStore, mh *mockBcryptHasher) {},
            wantedErr: errcode.ErrRequiredFieldMissing,
        },
        "パスワードをハッシュ化に失敗": {
            inputBody: &dto.SignupRequest{
                Username: "mock_user",
                Email:    "mock@example.com",
                Password: "password101",
            },
            setupMock: func(mu *mockUserStore, mh *mockBcryptHasher) {
                mh.On("Generate", "password101").Return("", errMockHashFailed)
            },
            wantedErr: errMockHashFailed,
            errMsg:    "パスワードをハッシュ化に失敗しました",
        },
        "データベース内部エラー": {
            inputBody: &dto.SignupRequest{
                Username: "mock_user",
                Email:    "mock@example.com",
                Password: "password101",
            },
            setupMock: func(mu *mockUserStore, mh *mockBcryptHasher) {
                mh.On("Generate", "password101").Return("mock_hash", nil)
                mu.On("Create", mock.Anything, mock.MatchedBy(func(user *models.User) bool {
                    return user.Username == "mock_user"
                })).Return(nil, errMockInternal)
            },
            wantedErr: errMockInternal,
            errMsg:    "登録に失敗しました",
        },
    }

    for name, tt := range tests {
        t.Run(name, func(t *testing.T) {
            mu := new(mockUserStore)
            mh := new(mockBcryptHasher)
            tt.setupMock(mu, mh)
            svc := NewUserService(mu, mh)
            ctx := context.Background()
            res, err := svc.Register(ctx, tt.inputBody.Username, tt.inputBody.Email, tt.inputBody.Password)

            if tt.wantedErr != nil {
                assert.ErrorIs(t, err, tt.wantedErr)
                if tt.errMsg != "" {
                    assert.Contains(t, err.Error(), tt.errMsg)
                }
                assert.Nil(t, res)
            } else {
                now := time.Now().UTC()
                require.NoError(t, err)
                require.NotNil(t, res)
                assert.Equal(t, tt.inputBody.Username, res.Username)
                assert.Equal(t, tt.inputBody.Email, res.Email)
                assert.NotZero(t, res.ID)
                assert.Equal(t, int64(1), res.ID)
                assert.False(t, res.CreatedAt.IsZero())
                assert.WithinDuration(t, now, res.CreatedAt, 10*time.Second)
                assert.Equal(t, time.UTC, res.CreatedAt.Location())
            }

            mh.AssertExpectations(t)
            mu.AssertExpectations(t)
        })
    }
}

func TestExistsByEmail(t *testing.T) {
    tests := map[string]struct {
        email          string
        setupMock      func(m *mockUserStore)
        wantErr        error
        expectedErrMsg string
    }{
        "【正常系】ユーザーが存在する場合、正常にユーザー情報を返す": {
            email: "exist@example.com",
            setupMock: func(m *mockUserStore) {
                m.On("GetByEmail", mock.Anything, "exist@example.com").
                    Return(&models.User{Email: "exist@example.com"}, nil)
            },
            wantErr: nil,
        },
        "【異常系】メールアドレスが空の場合、バリデーションエラーを返す": {
            email:     "",
            setupMock: func(m *mockUserStore) {},
            wantErr:   errcode.ErrRequiredFieldMissing,
        },
        "【異常系】ユーザーが存在しない場合、認証エラーに変換して返す（ユーザー列挙防止）": {
            email: "notfound@example.com",
            setupMock: func(m *mockUserStore) {
                m.On("GetByEmail", mock.Anything, "notfound@example.com").
                    Return(nil, errcode.ErrUserNotFound)
            },
            wantErr: errcode.ErrInvalidCredentials,
        },
        "【異常系】データベース接続エラー等の内部エラーが発生した場合": {
            email: "db@example.com",
            setupMock: func(m *mockUserStore) {
                m.On("GetByEmail", mock.Anything, "db@example.com").
                    Return(nil, errMockInternal )
            },
            wantErr: errMockInternal,
            expectedErrMsg: "ユーザー情報の取得に失敗しました",
        },
    }

    for name, tt := range tests {
        t.Run(name, func(t *testing.T) {
            mu := new(mockUserStore)
            tt.setupMock(mu)
            
            svc := &userService{userStore: mu} 
            
            ctx := context.Background()
            user, err := svc.existsByEmail(ctx, tt.email)

            if tt.wantErr != nil {
                assert.ErrorIs(t, err, tt.wantErr)
                assert.Nil(t, user)
                if tt.expectedErrMsg != "" {
                    assert.Contains(t, err.Error(), tt.expectedErrMsg)
                }
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, user)
                assert.Equal(t, tt.email, user.Email)
            }
            mu.AssertExpectations(t)
        })
    }
}

func TestLogin(t *testing.T) {
	gin.SetMode(gin.TestMode)
	tests := map[string]struct {
		email     string
		password  string
		setupMock func(mu *mockUserStore, mh *mockBcryptHasher)
		wantedErr error
		errMsg    string
	}{
		"【正常系】ログイン成功：正しい資格情報でユーザー情報を返す": {
			email:    "mock@example.com",
			password: "password123",
			setupMock: func(mu *mockUserStore, mh *mockBcryptHasher) {
				mu.On("GetByEmail", mock.Anything, "mock@example.com").Return(&models.User{
					ID: 1, Email: "mock@example.com", PasswordHash: "hashed_pass",
				}, nil)
				mh.On("Compare", "hashed_pass", "password123").Return(nil)
			},
			wantedErr: nil,
		},
		"【異常系】必須項目不足：パスワードが空の場合": {
			email:     "mock@example.com",
			password:  "",
			setupMock: func(mu *mockUserStore, mh *mockBcryptHasher) {},
			wantedErr: errcode.ErrRequiredFieldMissing,
		},
		"【異常系】認証失敗：ユーザーが存在しない場合（ユーザー列挙防止）": {
			email:    "none@example.com",
			password: "password123",
			setupMock: func(mu *mockUserStore, mh *mockBcryptHasher) {
				mu.On("GetByEmail", mock.Anything, "none@example.com").Return(nil, errcode.ErrUserNotFound)
			},
			wantedErr: errcode.ErrInvalidCredentials,
		},
		"【異常系】認証失敗：DB接続エラー等の内部エラー": {
			email:    "test@example.com",
			password: "password123",
			setupMock: func(ms *mockUserStore, mh *mockBcryptHasher) {
				ms.On("GetByEmail", mock.Anything, "test@example.com").Return(nil, errMockInternal)
			},
			wantedErr: errMockInternal,
			errMsg:    "ユーザー情報の取得に失敗しました",
		},
		"【異常系】認証失敗：パスワード不一致": {
			email:    "mock@example.com",
			password: "wrong-password",
			setupMock: func(mu *mockUserStore, mh *mockBcryptHasher) {
				mu.On("GetByEmail", mock.Anything, "mock@example.com").Return(&models.User{
					PasswordHash: "correct_hash",
				}, nil)
				mh.On("Compare", "correct_hash", "wrong-password").Return(fmt.Errorf("hash mismatch"))
			},
			wantedErr: errcode.ErrInvalidCredentials,
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			mu := new(mockUserStore)
			mh := new(mockBcryptHasher)
			tt.setupMock(mu, mh)

			svc := NewUserService(mu, mh)
			ctx := context.Background()
			res, err := svc.Login(ctx, tt.email, tt.password)

			if tt.wantedErr != nil {
				assert.ErrorIs(t, err, tt.wantedErr)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
				assert.Nil(t, res)
			} else {
				require.NoError(t, err)
				require.NotNil(t, res)
				assert.Equal(t, tt.email, res.Email)
			}
			mu.AssertExpectations(t)
			mh.AssertExpectations(t)
		})
	}
}

func TestToMyPage(t *testing.T) {
	tests := map[string]struct {
		userID    int64
		setupMock func(mu *mockUserStore)
		wantedErr error
		errMsg    string
	}{
		"取得成功": {
			userID: 1,
			setupMock: func(mu *mockUserStore) {
				mu.On("GetByID", mock.Anything, int64(1)).Return(&models.User{ID: 1}, nil)
			},
			wantedErr: nil,
		},
		"ユーザーID無効": {
			userID:    -1,
			setupMock: func(mu *mockUserStore) {},
			wantedErr: errcode.ErrInvalidUserID,
		},
		"データベース内部エラー": {
			userID: 1,
			setupMock: func(mu *mockUserStore) {
				mu.On("GetByID", mock.Anything, int64(1)).Return(nil, errMockInternal)
			},
			wantedErr: errMockInternal,
			errMsg:    "ユーザー情報の取得に失敗しました",
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			mu := new(mockUserStore)
			mh := new(mockBcryptHasher)
			tt.setupMock(mu)

			svc := NewUserService(mu, mh)
			res, err := svc.ToMyPage(context.Background(), tt.userID)

			if tt.wantedErr != nil {
				assert.ErrorIs(t, err, tt.wantedErr)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
				assert.Nil(t, res)
			} else {
				require.NoError(t, err)
				require.NotNil(t, res)
				assert.Equal(t, tt.userID, res.ID)
			}

			mu.AssertExpectations(t)
		})
	}
}
</file>

<file path="migrations/000001_create_initial_tables.down.sql">
DROP TABLE IF EXISTS "sessions";
DROP TABLE IF EXISTS "tweets";
DROP TABLE IF EXISTS "users";
</file>

<file path="migrations/000002_add_created_at_to_sessions.down.sql">
ALTER TABLE sessions 
DROP COLUMN IF EXISTS created_at;
</file>

<file path="migrations/000002_add_created_at_to_sessions.up.sql">
ALTER TABLE sessions
ADD COLUMN created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP;
</file>

<file path="migrations/000003_add_content_limit_to_tweets.down.sql">
ALTER TABLE "tweets" ALTER COLUMN "content" TYPE text;
</file>

<file path="migrations/000003_add_content_limit_to_tweets.up.sql">
ALTER TABLE "tweets" ALTER COLUMN "content" TYPE varchar(1000);
</file>

<file path="scripts/init-db/init.sql">
CREATE DATABASE aita_test_db;
</file>

<file path=".gitignore">
/aita
/cmd/api/api    
*.exe         
*.test 


.env

vendor/

.vscode/        
.idea/          
.DS_Store       
Thumbs.db       
go
go.sum.bak
</file>

<file path="internal/db/tweet_store.go">
package db

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

type postgresTweetStore struct {
	database *sqlx.DB
}

func NewPostgresTweetStore(DB *sqlx.DB) *postgresTweetStore {
	return &postgresTweetStore{database: DB}
}

func (s *postgresTweetStore) CreateTweet(ctx context.Context, tweet *models.Tweet) (*models.Tweet, error) {
	query := `
		INSERT INTO tweets(user_id, content, image_url)
		VALUES($1, $2, $3)
		RETURNING id, user_id, content, image_url, created_at, updated_at, is_edited`
	var newTweet models.Tweet
	err := s.database.QueryRowContext(
		ctx,
		query,
		tweet.UserID,
		tweet.Content,
		tweet.ImageURL,
	).Scan(
		&newTweet.ID,
		&newTweet.UserID,
		&newTweet.Content,
		&newTweet.ImageURL,
		&newTweet.CreatedAt,
		&newTweet.UpdatedAt,
		&newTweet.IsEdited, 
	)

	if err != nil {
		var pqErr *pq.Error
		if errors.As(err, &pqErr) {
			if pqErr.Code == errCodeForeignKeyViolation && pqErr.Constraint == constraintTweetUserFK {
				return nil, errcode.ErrUserNotFound
			}
			if pqErr.Code == errCodeStringDataRightTruncation {
				return nil, errcode.ErrValueTooLong
			}
		}

		return nil, fmt.Errorf("ツイートの挿入に失敗しました: %w", err)
	}

	newTweet.CreatedAt = newTweet.CreatedAt.UTC()
	newTweet.UpdatedAt = newTweet.UpdatedAt.UTC()
	return &newTweet, nil
}

func (s *postgresTweetStore) GetTweetByTweetID(ctx context.Context, tweetID int64) (*models.Tweet, error) {
	query := `SELECT user_id, content, image_url, created_at, updated_at, is_edited FROM tweets WHERE id = $1`
	var wantedTweet models.Tweet
	err := s.database.GetContext(ctx, &wantedTweet, query, tweetID)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, errcode.ErrTweetNotFound
		}
		return nil, fmt.Errorf("ツイートの取得に失敗しました: %w", err)
	}
	wantedTweet.CreatedAt = wantedTweet.CreatedAt.UTC()
	wantedTweet.UpdatedAt = wantedTweet.UpdatedAt.UTC()
	return &wantedTweet, nil
}

func (s *postgresTweetStore) UpdateContent(ctx context.Context, newContent string, tweetID int64) (*models.Tweet, error) {
	query := `UPDATE tweets 
		SET content = $1, is_edited = true
		WHERE id = $2 AND content <> $1 
		RETURNING id, user_id, content, image_url, created_at, updated_at, is_edited`
	var updatedTweet models.Tweet
	err := s.database.GetContext(ctx, &updatedTweet, query, newContent, tweetID)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, errcode.ErrTweetNotFound
		}
		var pqErr *pq.Error
		if errors.As(err, &pqErr) {
			if pqErr.Code == errCodeStringDataRightTruncation {
				return nil, errcode.ErrValueTooLong
			}
		}
		return nil, fmt.Errorf("ツイートの更新に失敗しました: %w", err)
	}

	updatedTweet.CreatedAt = updatedTweet.CreatedAt.UTC()
	updatedTweet.UpdatedAt = updatedTweet.UpdatedAt.UTC()
	return &updatedTweet, nil
}

func (s *postgresTweetStore) DeleteTweet(ctx context.Context, tweetID int64) error {
	query := `DELETE FROM tweets WHERE id = $1`
	result, err := s.database.ExecContext(ctx, query, tweetID)
	if err != nil {
		return fmt.Errorf("ツイートの削除に失敗しました: %w", err)
	}

	row, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("影響を受けた行数の取得に失敗しました: %w", err)
	}

	if row == 0 {
		return errcode.ErrTweetNotFound
	}

	return nil
}
</file>

<file path="internal/pkg/utils/helper.go">
package utils

import "regexp"

 func StringPtr(s string) *string {
 	if s == "" {
 		return nil
 	}
 	return &s
}

var emailRegex = regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,}$`)
func IsValidEmail(s string) bool {
	if len(s) < 3 || len(s) > 255 {
		return false
	}
	return emailRegex.MatchString(s)
}
</file>

<file path="internal/service/session_service_test.go">
package service

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"context"
	"strings"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestIssue(t *testing.T) {
	gin.SetMode(gin.TestMode)
	tests := map[string]struct {
		userID    int64
		setupMock func(ms *mockSessionStore, mt *mockTokenManager)
		wantedErr error
		errMsg    string
	}{
		"発行成功": {
			userID: 1,
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {
				rawToken := "generated_raw_token_32_characters_long"
				hashedToken := "hashed_token"

				mt.On("Generate", 32).Return(rawToken, nil)
				mt.On("Hash", rawToken).Return(hashedToken)
				expectedSession := &models.Session{
					ID:        1,
					UserID:    1,
					TokenHash: hashedToken,
					CreatedAt: time.Now().UTC(),
					ExpiresAt: time.Now().Add(24 * time.Hour).UTC(),
				}

				ms.On("Create", mock.Anything, mock.MatchedBy(func(s *models.Session) bool {
					return s.UserID == 1 && s.TokenHash == hashedToken
				})).Return(expectedSession, nil)
			},
			wantedErr: nil,
		},
		"バリデーションエラー": {
			userID:    0,
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {},
			wantedErr: errcode.ErrRequiredFieldMissing,
		},
		"トークン生成失敗": {
			userID: 1,
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {
				mt.On("Generate", 32).Return("", errMockTokenFailed)
			},
			wantedErr: errMockTokenFailed,
			errMsg:    "トークンの生成に失敗しました",
		},
		"DB保存失敗": {
			userID: 1,
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {
				mt.On("Generate", 32).Return("token", nil)
				mt.On("Hash", "token").Return("hash")
				ms.On("Create", mock.Anything, mock.Anything).Return(nil, errMockInternal)
			},
			wantedErr: errMockInternal,
			errMsg:    "発行に失敗しました",
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			ms := new(mockSessionStore)
			mu := new(mockUserService)
			mt := new(mockTokenManager)

			tt.setupMock(ms, mt)

			svc := NewSessionService(ms, mu, mt)
			res, err := svc.Issue(context.Background(), tt.userID)

			if tt.wantedErr != nil {
				assert.ErrorIs(t, err, tt.wantedErr)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
				assert.Empty(t, res) 
			} else {
				require.NoError(t, err)
				assert.Equal(t, "generated_raw_token_32_characters_long", res)
			}

			ms.AssertExpectations(t)
			mt.AssertExpectations(t)
		})
	}
}

func TestAuthenticate(t *testing.T) {
	type testCase struct {
		name      string
		token     string
		setupMock func(ms *mockSessionStore, mt *mockTokenManager)
		wantedErr error
		errMsg    string
	}
	tests := []testCase{
		{
			name:  "認証成功",
			token: "valid_token_that_is_long_enough_32char",
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {
				tokenHash := "hashed_token"
				mt.On("Hash", mock.Anything).Return(tokenHash)
				ms.On("GetByHash", mock.Anything, tokenHash).Return(&models.Session{
					ID:        1,
					UserID:    10,
					TokenHash: "hashed_token",
					ExpiresAt: time.Now().Add(24 * time.Hour).UTC(),
					CreatedAt: time.Now().UTC(),
				}, nil)
			},
			wantedErr: nil,
		},
		{
			name:      "Tokenが空",
			token:     "",
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {},
			wantedErr: errcode.ErrSessionNotFound,
		},
		{
			name:      "Tokenが短すぎる",
			token:     "too_short",
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {},
			wantedErr: errcode.ErrInvalidTokenFormat,
		},
		{
			name:      "Tokenが長すぎる",
			token:     strings.Repeat("a", 256),
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {},
			wantedErr: errcode.ErrInvalidTokenFormat,
		},
		{
			name:  "セッションが見つからない",
			token: "unknown_token_long_enough_32char",
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {
				mt.On("Hash", mock.Anything).Return("unknown_hash")
				ms.On("GetByHash", mock.Anything, "unknown_hash").Return(nil, errMockTokenFailed)
			},
			wantedErr: errMockTokenFailed,
			errMsg:    "セッションの取得に失敗しました",
		},
		{
			name:  "DB内部エラー",
			token: "valid_token_that_is_long_enough_32char",
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {
				mt.On("Hash", mock.Anything).Return("hash")
				ms.On("GetByHash", mock.Anything, "hash").Return(nil, errMockTokenFailed)
			},
			wantedErr: errMockTokenFailed,
			errMsg:    "セッションの取得に失敗しました",
		},
		{
			name:  "期限切れ",
			token: "valid_token_that_is_long_enough_32char",
			setupMock: func(ms *mockSessionStore, mt *mockTokenManager) {
				tokenHash := "hashed_token"
				mt.On("Hash", mock.Anything).Return(tokenHash)
				ms.On("GetByHash", mock.Anything, tokenHash).Return(&models.Session{
					ID:        1,
					UserID:    10,
					TokenHash: "hashed_token",
					ExpiresAt: time.Now().Add(-1 * time.Hour).UTC(),
					CreatedAt: time.Now().UTC(),
				}, nil)
			},
			wantedErr: errcode.ErrSessionExpired,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ms := new(mockSessionStore)
			mt := new(mockTokenManager)
			mu := new(mockUserService)

			tt.setupMock(ms, mt)

			svc := NewSessionService(ms, mu, mt)
			res, err := svc.authenticate(context.Background(), tt.token)

			if tt.wantedErr != nil {
				assert.ErrorIs(t, err, tt.wantedErr)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
				assert.Nil(t, res)
			} else if tt.errMsg != "" {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tt.errMsg)
			} else {
				require.NoError(t, err)
				assert.NotNil(t, res)
				assert.Equal(t, int64(10), res.UserID)
			}

			ms.AssertExpectations(t)
			mt.AssertExpectations(t)
		})
	}
}

func TestValidate(t *testing.T) {
	type testCase struct {
		name      string
		token     string
		setupMock func(ms *mockSessionStore, mu *mockUserService, mt *mockTokenManager)
		wantedErr error
		errMsg    string
	}

	validToken := "a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2"

	tests := []testCase{
		{
			name:      "【失敗】トークンが空（サービス層でのガード）",
			token:     "",
			setupMock: func(ms *mockSessionStore, mu *mockUserService, mt *mockTokenManager) {},
			wantedErr: errcode.ErrSessionNotFound,
		},
		{
			name:  "【失敗】データベース内部エラー",
			token: validToken,
			setupMock: func(ms *mockSessionStore, mu *mockUserService, mt *mockTokenManager) {
				mt.On("Hash", validToken).Return("hashed_ok")
				ms.On("GetByHash", mock.Anything, "hashed_ok").Return(nil, errMockInternal)
			},
			wantedErr: errMockInternal,
			errMsg:    "セッションの取得に失敗しました",
		},
		{
			name:  "【成功】標準的な検証",
			token: validToken,
			setupMock: func(ms *mockSessionStore, mu *mockUserService, mt *mockTokenManager) {
				mt.On("Hash", validToken).Return("hashed_ok")
				session := &models.Session{
					ID:        1,
					UserID:    10,
					TokenHash: "hashed_ok",
					ExpiresAt: time.Now().Add(23 * time.Hour).UTC(),
					CreatedAt: time.Now().Add(-1 * time.Hour).UTC(),
				}
				ms.On("GetByHash", mock.Anything, "hashed_ok").Return(session, nil)
				mu.On("ToMyPage", mock.Anything, int64(10)).Return(&models.User{ID: 10}, nil)
			},
			wantedErr: nil,
		},
		{
			name:  "【成功】セッションの自動更新がトリガーされる",
			token: validToken,
			setupMock: func(ms *mockSessionStore, mu *mockUserService, mt *mockTokenManager) {
				mt.On("Hash", validToken).Return("hashed_ok")
				oldExpiry := time.Now().Add(1 * time.Hour).UTC()
				session := &models.Session{
					ID:        1,
					UserID:    10,
					TokenHash: "hashed_ok",
					ExpiresAt: oldExpiry,
					CreatedAt: time.Now().Add(-23 * time.Hour).UTC(),
				}
				ms.On("GetByHash", mock.Anything, "hashed_ok").Return(session, nil)
				mu.On("ToMyPage", mock.Anything, int64(10)).Return(&models.User{ID: 10}, nil)
				ms.On("UpdateExpiresAt", mock.Anything, mock.MatchedBy(func(t time.Time) bool {
					expected := time.Now().Add(models.SessionDuration).UTC()
					return t.After(oldExpiry) && t.Sub(expected).Abs() < 10*time.Second
				}), int64(1)).Return(nil)
			},
			wantedErr: nil,
		},
		{
			name:  "【失敗】セッションは有効だがユーザーが存在しない（退会済みなど）",
			token: validToken,
			setupMock: func(ms *mockSessionStore, mu *mockUserService, mt *mockTokenManager) {
				mt.On("Hash", validToken).Return("hashed_ok")
				session := &models.Session{
					ID:        1,
					UserID:    10,
					TokenHash: "hashed_ok",
					ExpiresAt: time.Now().Add(24 * time.Hour).UTC(),
					CreatedAt: time.Now().Add(-1 * time.Hour).UTC(),
				}
				ms.On("GetByHash", mock.Anything, "hashed_ok").Return(session, nil)
				mu.On("ToMyPage", mock.Anything, int64(10)).Return(nil, errcode.ErrUserNotFound)
			},
			wantedErr: errcode.ErrUserNotFound,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ms := new(mockSessionStore)
			mt := new(mockTokenManager)
			mu := new(mockUserService)

			tt.setupMock(ms, mu, mt)
			svc := NewSessionService(ms, mu, mt)

			res, err := svc.Validate(context.Background(), tt.token)

			if tt.wantedErr != nil {
				assert.ErrorIs(t, err, tt.wantedErr)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
				assert.Nil(t, res)
			} else {
				require.NoError(t, err)
				assert.NotNil(t, res)

				if tt.name == "【成功】セッションの自動更新がトリガーされる" {
					expectedNewExpiry := time.Now().Add(models.SessionDuration).UTC()
					assert.WithinDuration(t, expectedNewExpiry, res.ExpiresAt, 10*time.Second)
				}
			}

			ms.AssertExpectations(t)
			mt.AssertExpectations(t)
			mu.AssertExpectations(t)
		})
	}
}

func TestRefreshSession(t *testing.T) {
	initialExpiry := time.Now().Add(-1 * time.Hour).UTC()
	session := &models.Session{
		ID:        1,
		UserID:    10,
		ExpiresAt: initialExpiry,
	}

	tests := []struct {
		name      string
		setupMock func(ms *mockSessionStore)
		wantErr   bool
		errMsg    string
	}{
		{
			name: "セッション期限が正常に更新される",
			setupMock: func(ms *mockSessionStore) {
				ms.On("UpdateExpiresAt", mock.Anything, mock.AnythingOfType("time.Time"), int64(1)).
					Return(nil)
			},
			wantErr: false,
		},
		{
			name: "データベース更新エラー",
			setupMock: func(ms *mockSessionStore) {
				ms.On("UpdateExpiresAt", mock.Anything, mock.Anything, int64(1)).
					Return(errMockInternal)
			},
			wantErr: true,
			errMsg:  "セッション期限の更新に失敗しました",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ms := new(mockSessionStore)
			mt := new(mockTokenManager)
			mu := new(mockUserService)

			tt.setupMock(ms)
			svc := NewSessionService(ms, mu, mt)

			err := svc.refreshSession(context.Background(), session)

			if tt.wantErr {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tt.errMsg)
			} else {
				assert.NoError(t, err)
				assert.True(t, session.ExpiresAt.After(initialExpiry), "ExpiresAt が更新後の方が新しくなっているべき")
				expectedExpiry := time.Now().Add(models.SessionDuration)
				assert.WithinDuration(t, expectedExpiry, session.ExpiresAt, 10*time.Second)
			}

			ms.AssertExpectations(t)
		})
	}
}

func TestRevoke(t *testing.T) {
	type testCase struct {
		name           string
		SessionID      int64
		setupMock      func(ms *mockSessionStore)
		wantedErr      error
		expectContains string
	}


	tests := []testCase{
		{
			name:  "【成功】正常にログアウトできる",
			SessionID : int64(101),
			setupMock: func(ms *mockSessionStore) {
				ms.On("DeleteBySessionID", mock.Anything,  int64(101)).Return(nil)
			},
			wantedErr: nil,
		},
		{
			name:      "【失敗】無効なセッションID",
			SessionID : int64(0),
			setupMock: func(ms *mockSessionStore) {},
			wantedErr: errcode.ErrInvalidSessionID,
		},
		{
			name:  "【失敗】DBエラー時にラップされたエラーを返す",
			SessionID : int64(101),
			setupMock: func(ms *mockSessionStore) {
				ms.On("DeleteBySessionID", mock.Anything, int64(101)).Return(errMockInternal)
			},
			wantedErr:      errMockInternal,
			expectContains: "セッションの削除に失敗しました",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ms := new(mockSessionStore)
			mt := new(mockTokenManager)
			mu := new(mockUserService)
			svc := NewSessionService(ms, mu, mt)

			tt.setupMock(ms)

			err := svc.Revoke(context.Background(), tt.SessionID)

			if tt.wantedErr != nil {
				assert.ErrorIs(t, err, tt.wantedErr)
				if tt.expectContains != "" {
					assert.Contains(t, err.Error(), tt.expectContains)
				}
			} else {
				assert.NoError(t, err)
			}
			ms.AssertExpectations(t)
			mt.AssertExpectations(t)
		})
	}
}
</file>

<file path="internal/service/session_service.go">
package service

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"context"
	"fmt"
	"time"
)

type SessionStore interface {
	Create(ctx context.Context, session *models.Session) (*models.Session, error)
	GetByHash(ctx context.Context, tokenHash string) (*models.Session, error)
	UpdateExpiresAt(ctx context.Context, expiresAt time.Time, id int64) error
    DeleteBySessionID(ctx context.Context, sessionID int64) error
}

type UserInfoProvider interface {
    ToMyPage(ctx context.Context, userID int64) (*models.User, error)
}

type TokenManager interface {
    Generate(length int) (string, error)
    Hash(token string) string
}


type sessionService struct {
    sessionStore SessionStore
    userService  UserInfoProvider
    tokenManager TokenManager
}

func NewSessionService(ss SessionStore, usvc UserInfoProvider, tm TokenManager) *sessionService {
    return &sessionService{
        sessionStore: ss,
        userService: usvc,
        tokenManager: tm,
    }
} 

func (s *sessionService) validateAndHash(token string) (string, error) {
    if token == ""  {
        return "", errcode.ErrSessionNotFound
    }
    if len(token) < 32 || len(token) > 255 {
        return "", errcode.ErrInvalidTokenFormat
    }
    return s.tokenManager.Hash(token), nil
}

func (s *sessionService) Issue(ctx context.Context, userID int64) (string, error) {
    if userID <= 0 {
        return "", errcode.ErrRequiredFieldMissing
    }

    token, err := s.tokenManager.Generate(32)
    if err != nil {
        return "", fmt.Errorf("トークンの生成に失敗しました: %w", err)
    }

    sessionData := &models.Session{
        UserID:    userID,
        TokenHash: s.tokenManager.Hash(token),
        ExpiresAt: time.Now().Add(24 * time.Hour).UTC(), 
    }

    _, err = s.sessionStore.Create(ctx, sessionData)
    if err != nil {
        return "", fmt.Errorf("発行に失敗しました: %w", err)
    }
    
    return token, nil
}

func (s *sessionService) authenticate(ctx context.Context, token string) (*models.Session, error) {
    tokenHash, err := s.validateAndHash(token)
    if err != nil {
        return nil, err
    }
    session, err := s.sessionStore.GetByHash(ctx, tokenHash)
    if err != nil {
        return nil, fmt.Errorf("セッションの取得に失敗しました: %w", err)
    }

    if session.IsExpired() {
        return nil, errcode.ErrSessionExpired
    }
    return session, nil
}

func (s *sessionService) Validate(ctx context.Context, token string) (*models.Session, error){
    session, err := s.authenticate(ctx, token)
    if err != nil {
        return nil, err
    }

    if _, err := s.userService.ToMyPage(ctx, session.UserID); err != nil {
        return nil, err
    }

    if session.ShouldRefresh() {
        if err := s.refreshSession(ctx, session); err != nil {
            return nil, err 
        }
    }
    return session, nil
}

func (s *sessionService) refreshSession(ctx context.Context, session *models.Session) error {
    newExpiry := time.Now().Add(models.SessionDuration).UTC()

    if err := s.sessionStore.UpdateExpiresAt(ctx, newExpiry, session.ID); err != nil {
        return fmt.Errorf("セッション期限の更新に失敗しました: %w", err)
    }

    session.ExpiresAt = newExpiry
    return nil
}

func (s *sessionService) Revoke(ctx context.Context, sessionID int64) error {
    if sessionID <= 0 {
        return errcode.ErrInvalidSessionID
    }
    err := s.sessionStore.DeleteBySessionID(ctx, sessionID)
    if err != nil {
        return fmt.Errorf("セッションの削除に失敗しました: %w", err)
    }

    return nil
}
</file>

<file path="internal/service/tweet_service_test.go">
package service

import (
	"aita/internal/dto"
	"aita/internal/errcode"
	"aita/internal/models"
	"aita/internal/pkg/utils"
	"context"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestPostTweet(t *testing.T) {
	gin.SetMode(gin.TestMode)
	imageURL := utils.StringPtr("https://example.com/mock.jpg")
	tests := []struct {
		name      string
		userID    int64
		inputBody *dto.CreateTweetRequest
		setupMock func(mt *mockTweetStore)
		wantedErr error
		errMsg    string
	}{
		{
			name:   "【正常系】ツイート投稿成功",
			userID: 101,
			inputBody: &dto.CreateTweetRequest{
				Content:  "Hello world",
				ImageURL: imageURL,
			},
			setupMock: func(mt *mockTweetStore) {
				expectedTweet := &models.Tweet{
					ID:        1,
					UserID:    101,
					Content:   "Hello world",
					ImageURL:  imageURL,
					CreatedAt: time.Now().UTC(),
					UpdatedAt: time.Now().UTC(),
				}
				mt.On("CreateTweet", mock.Anything, mock.MatchedBy(func(t *models.Tweet) bool {
					return t.UserID == 101 && t.Content == "Hello world" && t.ImageURL == imageURL
				})).Return(expectedTweet, nil)
			},
			wantedErr: nil,
		},
		{
			name:   "【異常系】無効なユーザーID",
			userID: -1,
			inputBody: &dto.CreateTweetRequest{
				Content: "Hello world",
			},
			setupMock: func(mt *mockTweetStore) {},
			wantedErr: errcode.ErrInvalidUserID,
		},
		{
			name:   "【異常系】コンテンツが空（必須項目不足）",
			userID: 101,
			inputBody: &dto.CreateTweetRequest{
				Content: "",
			},
			setupMock: func(mt *mockTweetStore) {},
			wantedErr: errcode.ErrRequiredFieldMissing,
		},
		{
			name:   "【異常系】データベースエラー（挿入失敗）",
			userID: 99999,
			inputBody: &dto.CreateTweetRequest{
				Content:  "Hello world",
				ImageURL: imageURL,
			},
			setupMock: func(mt *mockTweetStore) {
				mt.On("CreateTweet", mock.Anything, mock.MatchedBy(func(t *models.Tweet) bool {
					return t.UserID == 99999 && t.Content == "Hello world"
				})).Return(nil, errMockInternal)
			},
			wantedErr: errMockInternal,
			errMsg:    "ツイートの挿入に失敗しました",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mt := new(mockTweetStore)
			tt.setupMock(mt)
			svc := NewTweetService(mt)
			ctx := context.Background()

			res, err := svc.PostTweet(ctx, tt.userID, tt.inputBody.Content, tt.inputBody.ImageURL)

			if tt.wantedErr != nil {
				assert.ErrorIs(t, err, tt.wantedErr, "期待されるエラータイプが一致します")
				assert.Nil(t, res, "エラーが発生した場合は、レスポンスはnilであるべきです")
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
			} else {
				require.NoError(t, err)
				require.NotNil(t, res)
				assert.Equal(t, tt.inputBody.Content, res.Content)
				assert.Equal(t, tt.inputBody.ImageURL, res.ImageURL)
				assert.Equal(t, tt.userID, res.UserID)
				assert.Equal(t, time.UTC, res.CreatedAt.Location())
				assert.Equal(t, time.UTC, res.UpdatedAt.Location())
			}

			mt.AssertExpectations(t)
		})
	}
}

func TestFetchTweet(t *testing.T) {
	gin.SetMode(gin.TestMode)
	tests := []struct {
		name         string
		inputTweetID int64
		setupMock    func(mt *mockTweetStore)
		wantedErr    error
		errMsg       string
	}{
		{
			name:         "正常系: ツイートの取得に成功した",
			inputTweetID: 101,
			setupMock: func(mt *mockTweetStore) {
				expectedTweet := &models.Tweet{
					ID:        101,
					Content:   "mock",
					CreatedAt: time.Now().UTC(),
					UpdatedAt: time.Now().UTC(),
				}
				mt.On("GetTweetByTweetID", mock.Anything, int64(101)).Return(expectedTweet, nil)
			},
			wantedErr: nil,
		},
		{
			name:         "異常系:パラメーターエラー, 無効なツイートID",
			inputTweetID: 0,
			setupMock:    func(mt *mockTweetStore) {},
			wantedErr:    errcode.ErrInvalidTweetID,
		},
		{
			name:         "異常系：データベースエラー,ツイートが存在しない場合",
			inputTweetID: 101,
			setupMock: func(mt *mockTweetStore) {
				mt.On("GetTweetByTweetID", mock.Anything, int64(101)).Return(nil, errcode.ErrTweetNotFound)
			},
			wantedErr: errcode.ErrTweetNotFound,
			errMsg:    "ツイート情報の取得に失敗しました",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mt := new(mockTweetStore)
			tt.setupMock(mt)
			svc := NewTweetService(mt)
			ctx := context.Background()
			res, err := svc.FetchTweet(ctx, tt.inputTweetID)

			if tt.wantedErr != nil {
				assert.ErrorIs(t, err, tt.wantedErr)
				assert.Nil(t, res)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), "ツイート情報の取得に失敗しました")
				}
			} else {
				require.NoError(t, err)
				require.NotNil(t, res)
				assert.Equal(t, tt.inputTweetID, res.ID)
				assert.Equal(t, "mock", res.Content)
				assert.Equal(t, time.UTC, res.CreatedAt.Location())
				assert.Equal(t, time.UTC, res.UpdatedAt.Location())
			}

			mt.AssertExpectations(t)
		})
	}
}

func TestToMyTweet(t *testing.T) {
	gin.SetMode(gin.TestMode)
	tweetID := int64(101)
	userID := int64(102)
	tests := []struct {
		name         string
		inputTweetID int64
		inputUserID  int64
		setupMock    func(mt *mockTweetStore)
		wantedErr    error
		errMsg       string
	}{
		{
			name:         "正常系: 自分のツイートの取得に成功した",
			inputTweetID: 101,
			inputUserID:  102,
			setupMock: func(mt *mockTweetStore) {
				expectedTweet := &models.Tweet{
					ID:        tweetID,
					UserID:    userID,
					Content:   "mock",
					CreatedAt: time.Now().UTC(),
					UpdatedAt: time.Now().UTC(),
				}
				mt.On("GetTweetByTweetID", mock.Anything, tweetID).Return(expectedTweet, nil)
			},
			wantedErr: nil,
		},
		{
			name:         "異常系:パラメーターエラー, 無効なツイートID",
			inputTweetID: 0,
			inputUserID:  userID,
			setupMock:    func(mt *mockTweetStore) {},
			wantedErr:    errcode.ErrInvalidTweetID,
		},
		{
			name:         "異常系:パラメーターエラー, 無効なuserID",
			inputTweetID: tweetID,
			inputUserID:  0,
			setupMock:    func(mt *mockTweetStore) {},
			wantedErr:    errcode.ErrInvalidUserID,
		},
		{
			name:         "異常系：データベースエラー,ツイートが存在しない場合",
			inputTweetID: tweetID,
			inputUserID:  userID,
			setupMock: func(mt *mockTweetStore) {
				mt.On("GetTweetByTweetID", mock.Anything, tweetID).Return(nil, errcode.ErrUserNotFound)
			},
			wantedErr: errcode.ErrUserNotFound,
			errMsg:    "ツイート情報の取得に失敗しました",
		},
		{
			name:         "異常系：権限がない",
			inputTweetID: 101,
			inputUserID:  102,
			setupMock: func(mt *mockTweetStore) {
				abnormalTweet := &models.Tweet{
					ID:        tweetID,
					UserID:    999,
					Content:   "mock",
					CreatedAt: time.Now().UTC(),
					UpdatedAt: time.Now().UTC(),
				}
				mt.On("GetTweetByTweetID", mock.Anything, tweetID).Return(abnormalTweet, nil)
			},
			wantedErr: errcode.ErrForbidden,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mt := new(mockTweetStore)
			tt.setupMock(mt)
			svc := NewTweetService(mt)
			ctx := context.Background()
			res, err := svc.ToMyTweet(ctx, tt.inputTweetID, tt.inputUserID)

			if tt.wantedErr != nil {
				assert.ErrorIs(t, err, tt.wantedErr)
				assert.Nil(t, res)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), "ツイート情報の取得に失敗しました")
				}
			} else {
				require.NoError(t, err)
				require.NotNil(t, res)
				assert.Equal(t, tt.inputTweetID, res.ID)
				assert.Equal(t, "mock", res.Content)
				assert.Equal(t, time.UTC, res.CreatedAt.Location())
				assert.Equal(t, time.UTC, res.UpdatedAt.Location())
			}

			mt.AssertExpectations(t)
		})
	}
}

func TestEditTweet(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name         string
		inputContent string
		inputTweetID int64
		inputUserID  int64
		setupMock    func(mt *mockTweetStore)
		wantedErr    error
		errMsg       string
	}{
		{
			name:         "正常系：10分以内の編集が正常に完了する",
			inputContent: "updated content",
			inputTweetID: 101,
			inputUserID:  102,
			setupMock: func(mt *mockTweetStore) {
				existingTweet := &models.Tweet{
					ID:        101,
					UserID:    102,
					Content:   "content",
					CreatedAt: time.Now().UTC().Add(-5 * time.Minute),
					UpdatedAt: time.Now().UTC().Add(-5 * time.Minute),
				}
				mt.On("GetTweetByTweetID", mock.Anything, int64(101)).Return(existingTweet, nil)

				updatedTweet := &models.Tweet{
					ID: 101, 
					UserID: 102, 
					Content: "updated content",	
					CreatedAt: time.Now().UTC().Add(-5 * time.Minute),
					UpdatedAt: time.Now().UTC(),
					IsEdited: true,
				}
				mt.On("UpdateContent", mock.Anything, "updated content", int64(101)).Return(updatedTweet, nil)
			},
			wantedErr: nil,
		},
		{
			name:         "異常系：投稿から10分以上経過しているため編集不可",
			inputContent: "too late",
			inputTweetID: 101,
			inputUserID:  102,
			setupMock: func(mt *mockTweetStore) {
				oldTweet := &models.Tweet{
					ID:        101,
					UserID:    102,
					Content:   "content",
					CreatedAt: time.Now().UTC().Add(-11 * time.Minute),
				}
				mt.On("GetTweetByTweetID", mock.Anything, int64(101)).Return(oldTweet, nil)
			},
			wantedErr: errcode.ErrEditTimeExpired,
		},
		{
			name:         "異常系：他のユーザーのツイートは編集不可（権限エラー）",
			inputContent: "hack",
			inputTweetID: 101,
			inputUserID:  999,
			setupMock: func(mt *mockTweetStore) {
				existingTweet := &models.Tweet{
					ID:        101,
					UserID:    102,
					Content:   "content",
					CreatedAt: time.Now().UTC(),
				}
				mt.On("GetTweetByTweetID", mock.Anything, int64(101)).Return(existingTweet, nil)
			},
			wantedErr: errcode.ErrForbidden,
		},
		{
			name:         "正常系：内容に変更がない場合は早期リターンする",
			inputContent: "same content",
			inputTweetID: 101,
			inputUserID:  102,
			setupMock: func(mt *mockTweetStore) {
				existing := &models.Tweet{
					ID:        101,
					UserID:    102,
					Content:   "same content",
					CreatedAt: time.Now().UTC(),
				}
				mt.On("GetTweetByTweetID", mock.Anything, int64(101)).Return(existing, nil)
			},
			wantedErr: nil,
		},
		{
			name:         "異常系：データベースエラーによる更新失敗",
			inputContent: "new content",
			inputTweetID: 101,
			inputUserID:  102,
			setupMock: func(mt *mockTweetStore) {
				existingTweet := &models.Tweet{
					ID:        101,
					UserID:    102,
					Content:   "content",
					CreatedAt: time.Now().UTC(),
				}
				mt.On("GetTweetByTweetID", mock.Anything, int64(101)).Return(existingTweet, nil)
				mt.On("UpdateContent", mock.Anything, "new content", int64(101)).Return(nil, errMockInternal)
			},
			wantedErr: errMockInternal,
			errMsg:    "ツイート編集に失敗しました",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mt := new(mockTweetStore)
			tt.setupMock(mt)
			svc := NewTweetService(mt)

			res, bool, err := svc.EditTweet(context.Background(), tt.inputContent, tt.inputTweetID, tt.inputUserID)

			if tt.wantedErr != nil {
				if tt.errMsg != "" {
					assert.ErrorIs(t, err, tt.wantedErr)
					assert.Contains(t, err.Error(), tt.errMsg)
					t.Logf("エラーは %v\n", err)
					assert.Equal(t, false, bool)
				}
				assert.ErrorIs(t, err, tt.wantedErr)
				assert.Nil(t, res)
				assert.Equal(t, false, bool)
			} else {
				require.NoError(t, err)
				require.NotNil(t, res)
				require.Equal(t, tt.inputContent, res.Content)
			}

			mt.AssertExpectations(t)
		})
	}
}

func TestRemoveTweet(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name         string
		inputTweetID int64
		inputUserID  int64
		setupMock    func(mt *mockTweetStore)
		wantedErr    error
		errMsg       string
	}{
		{
			name:         "正常系: 自分のツイートが正常に削除される",
			inputTweetID: 201,
			inputUserID:  202,
			setupMock: func(mt *mockTweetStore) {
				existingTweet := &models.Tweet{ID: 201, UserID: 202}
				mt.On("GetTweetByTweetID", mock.Anything, int64(201)).Return(existingTweet, nil)
				mt.On("DeleteTweet", mock.Anything, int64(201)).Return(nil)
			},
			wantedErr: nil,
		},
		{
			name:         "異常系: ツイートが存在しない場合は削除不可",
			inputTweetID: 404,
			inputUserID:  202,
			setupMock: func(mt *mockTweetStore) {
				mt.On("GetTweetByTweetID", mock.Anything, int64(404)).Return(nil, errcode.ErrTweetNotFound)
			},
			wantedErr: errcode.ErrTweetNotFound,
		},
		{
			name:         "異常系: 他人のツイートは削除不可（権限エラー）",
			inputTweetID: 201,
			inputUserID:  999,
			setupMock: func(mt *mockTweetStore) {
				existingTweet := &models.Tweet{ID: 201, UserID: 202}
				mt.On("GetTweetByTweetID", mock.Anything, int64(201)).Return(existingTweet, nil)
			},
			wantedErr: errcode.ErrForbidden,
		},
		{
			name:         "異常系: DBエラーによる削除失敗",
			inputTweetID: 201,
			inputUserID:  202,
			setupMock: func(mt *mockTweetStore) {
				existingTweet := &models.Tweet{ID: 201, UserID: 202}
				mt.On("GetTweetByTweetID", mock.Anything, int64(201)).Return(existingTweet, nil)
				mt.On("DeleteTweet", mock.Anything, int64(201)).Return(errMockInternal)
			},
			wantedErr: errMockInternal,
			errMsg:    "ツイートの削除に失敗しました",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mt := new(mockTweetStore)
			tt.setupMock(mt)
			svc := NewTweetService(mt)
			ctx := context.Background()

			err := svc.RemoveTweet(ctx, tt.inputTweetID, tt.inputUserID)

			if tt.wantedErr != nil {
				if tt.errMsg != "" {
					assert.ErrorIs(t, err, tt.wantedErr)
					assert.Contains(t, err.Error(), tt.errMsg)
					t.Logf("エラーは %v\n", err)
				}
				assert.ErrorIs(t, err, tt.wantedErr)
			} else {
				require.NoError(t, err)
			}

			mt.AssertExpectations(t)
		})
	}
}
</file>

<file path="internal/service/user_service.go">
package service

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"context"
	"errors"
	"fmt"
)

type UserStore interface {
	Create(ctx context.Context, user *models.User) (*models.User, error)
	GetByEmail(ctx context.Context, email string) (*models.User, error)
	GetByID(ctx context.Context, id int64) (*models.User, error)
}

type PasswordHasher interface {
	Generate(password string) (string, error)
	Compare(hashedPassword, password string) error
}
type userService struct {
	userStore UserStore
	hasher    PasswordHasher
}

func NewUserService(us UserStore, h PasswordHasher) *userService {
	return &userService{
		userStore: us,
		hasher:    h,
	}
}

func (s *userService) Register(ctx context.Context, username, email,password string) (*models.User, error) {
	if username == "" || email == "" || password == "" {
        return nil, errcode.ErrRequiredFieldMissing
    }

	hash, err := s.hasher.Generate(password)
	if err != nil {
		return nil, fmt.Errorf("パスワードをハッシュ化に失敗しました: %w", err)
	}

	user := &models.User{
		Username:     username,
		Email:        email,
		PasswordHash: hash,
	}

	user, err = s.userStore.Create(ctx, user)
	if err != nil {
		return nil, fmt.Errorf("登録に失敗しました: %w", err)
	}
	return user, nil
}

func (s *userService) existsByEmail(ctx context.Context, email string) (*models.User, error) {
	if email == "" {
		return nil, errcode.ErrRequiredFieldMissing
	}

	user, err := s.userStore.GetByEmail(ctx, email)
	if err != nil {
		if errors.Is(err, errcode.ErrUserNotFound) {
			return nil, errcode.ErrInvalidCredentials
		}
		return nil, fmt.Errorf("ユーザー情報の取得に失敗しました: %w", err)
	}

	return user, nil
}


func (s *userService) Login(ctx context.Context, email, password string) (*models.User, error) {
	if email == "" || password == "" {
		return nil, errcode.ErrRequiredFieldMissing
	}
	user, err := s.existsByEmail(ctx, email) 
	if err != nil {
		return nil, err
	}
	err = s.hasher.Compare(user.PasswordHash, password)
	if err != nil {
		return nil, errcode.ErrInvalidCredentials
	}
	return user, nil
}

func (s *userService) ToMyPage(ctx context.Context, userID int64) (*models.User, error) {
	if userID <= 0 {
		return nil, errcode.ErrInvalidUserID
	}
	user, err := s.userStore.GetByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("ユーザー情報の取得に失敗しました: %w", err)
	}
	return user, nil
}
</file>

<file path="docker-compose.yml">
services:
  postgres:
    image: postgres:15-alpine
    container_name: aita_postgres_v2  
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    ports:
      - "${DB_PORT}:5432" 
    volumes:
      - postgres_data_v2:/var/lib/postgresql/data
      - ./scripts/init-db:/docker-entrypoint-initdb.d
    networks:
      - aita_network

  redis:
    image: redis:7-alpine
    container_name: aita_redis
    ports:
      - "${REDIS_PORT}:6379"  
    volumes:
      - redis_data:/data
    command: ["redis-server", "--appendonly", "yes"] 
    networks:
      - aita_network

networks:
  aita_network:
    driver: bridge

volumes:
  postgres_data_v2:
  redis_data:
</file>

<file path="internal/api/middleware_test.go">
package api

import (
	"aita/internal/contextkeys"
	"aita/internal/dto"
	"aita/internal/errcode"
	"aita/internal/models"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

func TestAuthMiddleware(t *testing.T) {
    gin.SetMode(gin.TestMode)

    session123 := &models.Session{ID: 10, UserID: 123}
    session456 := &models.Session{ID: 20, UserID: 456}

    tests := []struct {
        name            string
        authHeader      string
        setupMock       func(m *mockSessionService)
        expectedStatus  int
        expectedSession *models.Session 
    }{
        {
            name:       "【成功】有効なBearerトークン",
            authHeader: "Bearer valid_token",
            setupMock: func(m *mockSessionService) {
                m.On("Validate", mock.Anything, "valid_token").Return(session123, nil)
            },
            expectedStatus:  http.StatusOK,
            expectedSession: session123,
        },
        {
            name:       "【成功】大文字のBEARERでも認識される",
            authHeader: "BEARER upper_token",
            setupMock: func(m *mockSessionService) {
                m.On("Validate", mock.Anything, "upper_token").Return(session456, nil)
            },
            expectedStatus:  http.StatusOK,
            expectedSession: session456,
        },
        {
            name:            "【失败】ヘッダーが空 (Serviceは呼ばれない)",
            authHeader:      "",
            setupMock:       func(m *mockSessionService) {},
            expectedStatus:  http.StatusUnauthorized,
            expectedSession: nil,
        },
        {
            name:            "【失败】Bearerプレフィックスがない (Serviceは呼ばれない)",
            authHeader:      "just_token_without_bearer",
            setupMock:       func(m *mockSessionService) {},
            expectedStatus:  http.StatusUnauthorized,
            expectedSession: nil,
        },
        {
            name:            "【失败】Bearerのみでトークンが空 (Serviceは呼ばれない)",
            authHeader:      "Bearer ",
            setupMock:       func(m *mockSessionService) {},
            expectedStatus:  http.StatusUnauthorized,
            expectedSession: nil,
        },
        {
            name:            "【失败】スキームがBasic (Serviceは呼ばれない)",
            authHeader:      "Basic dXNlcjpwYXNz",
            setupMock:       func(m *mockSessionService) {},
            expectedStatus:  http.StatusUnauthorized,
            expectedSession: nil,
        },
        {
            name:       "【失败】トークンが期限切れ (extractは成功するがServiceで失敗)",
            authHeader: "Bearer expired_token",
            setupMock: func(m *mockSessionService) {
                m.On("Validate", mock.Anything, "expired_token").Return(nil, errcode.ErrSessionExpired)
            },
            expectedStatus:  http.StatusUnauthorized,
            expectedSession: nil,
        },
        {
            name:       "【失败】ユーザー不在 (404 Not Foundを返す映射を確認)",
            authHeader: "Bearer ghost_user_token",
            setupMock: func(m *mockSessionService) {
                m.On("Validate", mock.Anything, "ghost_user_token").Return(nil, errcode.ErrUserNotFound)
            },
            expectedStatus:  http.StatusNotFound,
            expectedSession: nil,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ms := new(mockSessionService)
            tt.setupMock(ms)

            w := httptest.NewRecorder()
            r := gin.New()

            r.Use(AuthMiddleware(ms))

            r.GET("/test", func(c *gin.Context) {
                val, exists := c.Get(contextkeys.AuthPayloadKey)
                if exists {
                    auth, ok := val.(*dto.AuthContext)
                    if ok {
                        c.JSON(http.StatusOK, auth)
                        return
                    }
                }
                c.Status(http.StatusOK)
            })

            req := httptest.NewRequest(http.MethodGet, "/test", nil)
            if tt.authHeader != "" {
                req.Header.Set("Authorization", tt.authHeader)
            }
            r.ServeHTTP(w, req)

            assert.Equal(t, tt.expectedStatus, w.Code)

            if tt.expectedStatus == http.StatusOK && tt.expectedSession != nil {
                var resp dto.AuthContext
                json.Unmarshal(w.Body.Bytes(), &resp)
                
                assert.Equal(t, tt.expectedSession.UserID, resp.UserID, "UserIDが正しく変換されていること")
                assert.Equal(t, tt.expectedSession.ID, resp.SessionID, "SessionIDが正しく変換されていること")
            }

            ms.AssertExpectations(t)
        })
    }
}
</file>

<file path="internal/api/mock_test.go">
package api

import (
	"aita/internal/models"
	"aita/internal/pkg/testutils"
	"context"

	"github.com/stretchr/testify/mock"
)

type mockUserService struct {
	mock.Mock
}

type mockSessionService struct {
	mock.Mock
}

type mockTweetService struct {
	mock.Mock
}

func (m *mockUserService) Register(ctx context.Context, username string, email string, password string) (*models.User, error)  {
	args := m.Called(ctx, username, email, password)
	return testutils.SafeGet[models.User](args, 0), args.Error(1)
}

func (m *mockUserService) Login(ctx context.Context, email, password string) (*models.User, error) {
	args := m.Called(ctx, email, password)
	return testutils.SafeGet[models.User](args, 0), args.Error(1)
}

func (m *mockUserService) ToMyPage(ctx context.Context, userID int64) (*models.User, error) {
	args := m.Called(ctx, userID)
	return testutils.SafeGet[models.User](args, 0), args.Error(1)
}

func (m *mockSessionService) Issue(ctx context.Context, userID int64) (string, error) {
	args := m.Called(ctx, userID)
	return args.String(0), args.Error(1)
}

func (m *mockSessionService) Revoke(ctx context.Context, sessionID int64) error {
	args := m.Called(ctx, sessionID)
	return args.Error(0)
}

func (m *mockSessionService) Validate(ctx context.Context, token string) (*models.Session, error) {
	args := m.Called(ctx, token)
	return testutils.SafeGet[models.Session](args, 0), args.Error(1)
}

func (m *mockTweetService) PostTweet(ctx context.Context, userID int64, content string, imageURL *string) (*models.Tweet, error) {
	args := m.Called(ctx, userID, content, imageURL)
	return testutils.SafeGet[models.Tweet](args, 0), args.Error(1)
}

func (m *mockTweetService) FetchTweet(ctx context.Context, tweetID int64) (*models.Tweet, error) {
	args := m.Called(ctx, tweetID)
	return testutils.SafeGet[models.Tweet](args, 0), args.Error(1)
}


func (m *mockTweetService) EditTweet(ctx context.Context, newContent string, tweetID int64, userID int64)  (*models.Tweet, bool, error) {
	args := m.Called(ctx,newContent, tweetID, userID)
	return testutils.SafeGet[models.Tweet](args, 0), args.Bool(1), args.Error(2)
}

func (m *mockTweetService) RemoveTweet(ctx context.Context, tweetID int64, userID int64) error {
	args := m.Called(ctx, tweetID, userID)
	return args.Error(0)
}
</file>

<file path="internal/db/tweet_store_test.go">
package db

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"aita/internal/pkg/testutils"
	"aita/internal/pkg/utils"
	"context"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCreateTweet(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "henry",
		Email:        "text@example.com",
		PasswordHash: "passwordHash",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)
	t.Run("正常にツイートできること", func(t *testing.T) {
		tweet := &models.Tweet{
			UserID:   createdUser.ID,
			Content:  "これはテスト用のツイート投稿です",
			ImageURL: utils.StringPtr("https://example.com/image.jpg"),
		}
		createdTweet, err := testTweetStore.CreateTweet(ctx, tweet)
		require.NoError(t, err, "CreatedTweetはエラーを返すべきではありません")
		require.NotZero(t, createdTweet.ID, "投稿後、IDが発番されるはずです")
		require.NotZero(t, createdTweet.CreatedAt, "投稿後、作成日時がセットされるはずです")
		require.NotZero(t, createdTweet.CreatedAt)
    	require.NotZero(t, createdTweet.UpdatedAt)
		assert.Equal(t, tweet.UserID, createdTweet.UserID)
		assert.Equal(t, tweet.Content, createdTweet.Content)
		assert.Equal(t, tweet.ImageURL, createdTweet.ImageURL)
		assert.WithinDuration(t, createdTweet.CreatedAt, createdTweet.UpdatedAt, 1*time.Second)
		assert.Equal(t, time.UTC, createdTweet.CreatedAt.Location())
		assert.Equal(t, time.UTC, createdTweet.UpdatedAt.Location())
		assert.WithinDuration(t, time.Now(), createdTweet.CreatedAt, 10*time.Second)
		assert.Equal(t, false, createdTweet.IsEdited)
	})
}

func TestCreateTweetWhileError(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "henry",
		Email:        "text@example.com",
		PasswordHash: "passwordHash",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	t.Run("存在しないUserIDNの場合は、ErrUserNotFoundを返すこと", func(t *testing.T) {
		badTweet := &models.Tweet{
			UserID:  99999,
			Content: "存在しないユーザーのツイート",
		}
		createdTweet, err := testTweetStore.CreateTweet(ctx, badTweet)
		require.Error(t, err, "ユーザーが存在しない場合、エラーを返すべきです")
		require.ErrorIs(t, err, errcode.ErrUserNotFound, "エラーはErrUserNotFoundであるべきです")
		require.Nil(t, createdTweet, "エラー時、生成されたツイートはnilであるべきです")
	})

	t.Run("Contentが制限文字数を超えた場合、ErrValueTooLongを返すこと", func(t *testing.T) {
		longContent := strings.Repeat("a", 3000)
		badTweet := &models.Tweet{
			UserID:  createdUser.ID,
			Content: longContent,
		}
		_, err := testTweetStore.CreateTweet(ctx, badTweet)

		require.Error(t, err)
		require.ErrorIs(t, err, errcode.ErrValueTooLong, "DBの切捨てエラーが正しくマッピングされること")
	})

	t.Run("データベース切断時の時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, err := testutils.OpenDB(testContext.DSN)
		require.NoError(t, err)

		tempTweetStore := NewPostgresTweetStore(tempDB)
		tempDB.Close()

		tweet := &models.Tweet{
			UserID:   createdUser.ID,
			Content:  "これはテスト用のツイート投稿です",
			ImageURL: utils.StringPtr("https://example.com/image.jpg"),
		}
		createdTweet, err := tempTweetStore.CreateTweet(ctx, tweet)
		require.Error(t, err, "内部エラーの場合、エラーを返すべきです")
		assert.Contains(t, err.Error(), "ツイートの挿入に失敗しました")
		t.Logf("エラーは: %v\n", err)
		assert.Nil(t, createdTweet, "エラー時、生成されたツイートはnilであるべきです")
	})
}

func TestGetTweetByTweetID(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "henry",
		Email:        "text@example.com",
		PasswordHash: "passwordHash",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	initTweet := &models.Tweet{
		UserID:   createdUser.ID,
		Content:  "これはテスト用のツイート投稿です",
		ImageURL: utils.StringPtr("https://example.com/image.jpg"),
	}

	createdTweet, err := testTweetStore.CreateTweet(ctx, initTweet)
	require.NoError(t, err)

	t.Run("正常系:ツイートをTweetIDで取得に成功したこと", func(t *testing.T) {
		foundTweet, err := testTweetStore.GetTweetByTweetID(ctx, createdTweet.ID)
		require.NoError(t, err)
		require.NotNil(t, foundTweet)
		assert.Equal(t, createdTweet.UserID, foundTweet.UserID)
		assert.Equal(t, createdTweet.Content, foundTweet.Content)
		assert.Equal(t, createdTweet.ImageURL, foundTweet.ImageURL)
		assert.Equal(t, createdTweet.CreatedAt, foundTweet.CreatedAt)
		assert.Equal(t, createdTweet.UpdatedAt, foundTweet.UpdatedAt)
		assert.Equal(t, time.UTC, createdTweet.CreatedAt.Location())
		assert.Equal(t, time.UTC, createdTweet.UpdatedAt.Location())
		assert.Equal(t, createdTweet.IsEdited, foundTweet.IsEdited)
	})
}

func TestGetTweetByTweetIDWhileErr(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "henry",
		Email:        "text@example.com",
		PasswordHash: "passwordHash",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	initTweet := &models.Tweet{
		UserID:   createdUser.ID,
		Content:  "これはテスト用のツイート投稿です",
		ImageURL: utils.StringPtr("https://example.com/image.jpg"),
	}

	createdTweet, err := testTweetStore.CreateTweet(ctx, initTweet)
	require.NoError(t, err)

	t.Run("異常系:TweetIDがないこと", func(t *testing.T) {
		foundTweet, err := testTweetStore.GetTweetByTweetID(ctx, int64(999))
		assert.ErrorIs(t, err, errcode.ErrTweetNotFound)
		assert.Nil(t, foundTweet)
	})

	t.Run("異常系:データベース切断時の時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, err := testutils.OpenDB(testContext.DSN)
		require.NoError(t, err)
		tempTweetStore := NewPostgresTweetStore(tempDB)
		tempDB.Close()
		foundTweet, err := tempTweetStore.GetTweetByTweetID(ctx, createdTweet.ID)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "ツイートの取得に失敗しました")
		t.Logf("エラーは: %v\n", err)
		assert.Nil(t, foundTweet)
	})
}

func TestUpdateContent(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "henry",
		Email:        "text@example.com",
		PasswordHash: "passwordHash",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	initTweet := &models.Tweet{
		UserID:   createdUser.ID,
		Content:  "これはテスト用のツイート投稿です",
		ImageURL: utils.StringPtr("https://example.com/image.jpg"),
	}

	createdTweet, err := testTweetStore.CreateTweet(ctx, initTweet)
	require.NoError(t, err)

	t.Run("正常系:ツイートの更新に成功したこと", func(t *testing.T) {
		newContent := "Contentが更新しました"
		updatedTweet, err := testTweetStore.UpdateContent(ctx, newContent, createdTweet.ID)
		require.NoError(t, err)
		require.NotNil(t, updatedTweet)
		assert.Equal(t, createdTweet.ID, updatedTweet.ID)
		assert.Equal(t, createdTweet.UserID, updatedTweet.UserID)
		assert.Equal(t, createdTweet.CreatedAt, updatedTweet.CreatedAt)
		assert.Equal(t, newContent, updatedTweet.Content)
		assert.WithinDuration(t, time.Now(), updatedTweet.UpdatedAt, 2*time.Second)
		assert.Equal(t, true, updatedTweet.IsEdited)
	})
}

func TestUpdateContentWhileErr(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "henry",
		Email:        "text@example.com",
		PasswordHash: "passwordHash",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	initTweet := &models.Tweet{
		UserID:   createdUser.ID,
		Content:  "これはテスト用のツイート投稿です",
		ImageURL: utils.StringPtr("https://example.com/image.jpg"),
	}

	createdTweet, err := testTweetStore.CreateTweet(ctx, initTweet)
	require.NoError(t, err)

	t.Run("異常系:contentが長すぎ", func(t *testing.T) {
		newContent := strings.Repeat("a", 1001)
		updatedTweet, err := testTweetStore.UpdateContent(ctx, newContent, createdTweet.ID)
		assert.ErrorIs(t, err, errcode.ErrValueTooLong)
		assert.Nil(t, updatedTweet)
	})

	t.Run("異常系:TweetIDがないこと", func(t *testing.T) {
		newContent := "Contentが更新しました"
		updatedTweet, err := testTweetStore.UpdateContent(ctx, newContent, int64(999))
		assert.ErrorIs(t, err, errcode.ErrTweetNotFound)
		assert.Nil(t, updatedTweet)
	})

	t.Run("異常系:データベース切断時の時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, err := testutils.OpenDB(testContext.DSN)
		require.NoError(t, err)
		tempTweetStore := NewPostgresTweetStore(tempDB)
		tempDB.Close()

		newContent := "Contentが更新しました"
		updatedTweet, err := tempTweetStore.UpdateContent(ctx, newContent, createdTweet.ID)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "ツイートの更新に失敗しました")
		t.Logf("エラーは: %v\n", err)
		assert.Nil(t, updatedTweet)
	})

}

func TestDeleteTweet(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "henry",
		Email:        "text@example.com",
		PasswordHash: "passwordHash",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	initTweet := &models.Tweet{
		UserID:   createdUser.ID,
		Content:  "これはテスト用のツイート投稿です",
		ImageURL: utils.StringPtr("https://example.com/image.jpg"),
	}
	createdTweet, err := testTweetStore.CreateTweet(ctx, initTweet)

	t.Run("正常系: ツイートの削除に成功したこと", func(t *testing.T) {
		err = testTweetStore.DeleteTweet(ctx, createdTweet.ID)
		require.NoError(t, err)
		res, err := testTweetStore.GetTweetByTweetID(ctx, createdTweet.ID)
		require.Error(t, err)
		require.Nil(t, res)
	})
}

func TestDeleteTweetWhileErr(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()

	initUser := &models.User{
		Username:     "henry",
		Email:        "text@example.com",
		PasswordHash: "passwordHash",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	initTweet := &models.Tweet{
		UserID:   createdUser.ID,
		Content:  "これはテスト用のツイート投稿です",
		ImageURL: utils.StringPtr("https://example.com/image.jpg"),
	}
	createdTweet, err := testTweetStore.CreateTweet(ctx, initTweet)

	t.Run("異常系: TweetIDがないこと", func(t *testing.T) {
		err = testTweetStore.DeleteTweet(ctx, int64(999))
		assert.ErrorIs(t, err, errcode.ErrTweetNotFound)
	})

	t.Run("異常系:データベース切断時の時、ラップされたエラーを返すこと", func(t *testing.T) {
		temp, err := testutils.OpenDB(testContext.DSN)
		require.NoError(t, err)
		tempTweetStore := NewPostgresTweetStore(temp)
		temp.Close()

		err = tempTweetStore.DeleteTweet(ctx, createdTweet.ID)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "ツイートの削除に失敗しました")
		t.Logf("エラーは: %v\n", err)
	})

}
</file>

<file path="internal/db/user_store_test.go">
package db

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"aita/internal/pkg/testutils"
	"context"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestCreate(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()
	initUser := &models.User{
		Username:     "henry",
		Email:        "text@example.com",
		PasswordHash: "hashedpassword",
	}

	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err, "CreatedUserはエラーを返すべきではありません")
	require.NotNil(t, createdUser, "作成されたユーザーオブジェクトは空であるべきではありません")
	assert.Equal(t, initUser.Username, createdUser.Username, "ユーザー名は一致するべきです")
	assert.Equal(t, initUser.Email, createdUser.Email, "メールは一致する必要があります")
	assert.Equal(t, initUser.PasswordHash, createdUser.PasswordHash, "パスワードハッシュは空であるべきではありません")
	assert.NotZero(t, createdUser.ID, "IDは自動生成されるべきです")
	assert.NotZero(t, createdUser.CreatedAt, "CreatedAtは自動生成されるべきです")
	assert.Equal(t, time.UTC, createdUser.CreatedAt.Location(), "CreatedAtはUTCであるべきです")
}

func TestCreateWhileConflict(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()
	initUser := &models.User{
		Username:     "henry",
		Email:        "text@example.com",
		PasswordHash: "hashedpassword",
	}
	_, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	t.Run("23505: ユーザー名の競合", func(t *testing.T) {
		newUser := &models.User{
			Username:     "henry",
			Email:        "other@example.com",
			PasswordHash: "secretpassword",
		}
		createdUser, err := testUserStore.Create(ctx, newUser)

		assert.ErrorIs(t, err, errcode.ErrUsernameConflict, "エラーはErrUsernameConflictであるべきです")
		assert.Nil(t, createdUser, "エラー時、生成されたユーザーはnilであるべきです")
	})

	t.Run("23505: メールアドレスの競合", func(t *testing.T) {
		newUser := &models.User{
			Username:     "Test_name",
			Email:        "text@example.com",
			PasswordHash: "secretpassword",
		}
		createdUser, err := testUserStore.Create(ctx, newUser)
		assert.ErrorIs(t, err, errcode.ErrEmailConflict, "エラーはErrEmailConflictであるべきです")
		assert.Nil(t, createdUser, "エラー時、生成されたユーザーはnilであるべきです")
	})
}

func TestCreateWhileAnotherErr(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()
	t.Run("22001: 文字列長超過", func(t *testing.T) {
		newUser := &models.User{
			Username:     strings.Repeat("u", 51),
			Email:        "long@example.com",
			PasswordHash: "sercretpassword",
		}
		createdUser, err := testUserStore.Create(ctx, newUser)
		assert.ErrorIs(t, err, errcode.ErrValueTooLong)
		assert.Nil(t, createdUser)

	})

	t.Run("データベース切断時の時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, err := testutils.OpenDB(testContext.DSN)
		require.NoError(t, err)

		tempUserStore := NewPostgresUserStore(tempDB)
		tempDB.Close()

		newUser := &models.User{
			Username:     "henry",
			Email:        "text@example.com",
			PasswordHash: "hashedpassword",
		}
		createdUser, err := tempUserStore.Create(ctx, newUser)
		require.Error(t, err, "内部エラーの場合、エラーを返すべきです")
		assert.Contains(t, err.Error(), "ユーザーの生成に失敗しました")
		t.Logf("エラーは: %v\n", err)
		assert.Nil(t, createdUser, "エラー時、生成されたユーザーはnilであるべきです")
	})
}

func TestGetByEmail(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()
	initUser := &models.User{
		Username:     "henry",
		Email:        "get@example.com",
		PasswordHash: "hashedpassword",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)
	t.Run("ユーザーが存在する", func(t *testing.T) {
		foundUser, err := testUserStore.GetByEmail(ctx, "get@example.com")
		require.NoError(t, err, "ユーザーが存在する場合、エラーを返すべきではありません")
		require.NotNil(t, foundUser, "見つかったユーザーは空であってはなりません")
		assert.Equal(t, createdUser.ID, foundUser.ID, "見つかったユーザーIDが一致するはずです")
		assert.Equal(t, createdUser.Username, foundUser.Username, "見つかったユーザー名が一致するはずです")
		assert.Equal(t, createdUser.Email, foundUser.Email, "見つかったメールアドレスが一致するはずです")
		assert.Equal(t, createdUser.PasswordHash, foundUser.PasswordHash, "見つかったPasswordHashが一致するはずです")
		assert.True(t, createdUser.CreatedAt.Equal(foundUser.CreatedAt), "CreatedAtは一致するべきです")
	})
}

func TestGetByEmailWhileError(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()
	initUser := &models.User{
		Username:     "henry",
		Email:        "get@example.com",
		PasswordHash: "hashedpassword",
	}
	_, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	t.Run("ユーザーが存在しない", func(t *testing.T) {
		unfoundUser, err := testUserStore.GetByEmail(ctx, "wrong@example.com")
		assert.ErrorIs(t, err, errcode.ErrUserNotFound)
		assert.Nil(t, unfoundUser)
	})

	t.Run("データベース切断時の時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, err := testutils.OpenDB(testContext.DSN)
		require.NoError(t, err)

		tempUserStore := NewPostgresUserStore(tempDB)
		tempDB.Close()

		unfoundUser, err := tempUserStore.GetByEmail(ctx, "get@example.com")
		require.Error(t, err)
		assert.Contains(t, err.Error(), "emailによるユーザー取得に失敗しました")
		t.Logf("エラーは: %v\n", err)
		assert.Nil(t, unfoundUser)
	})
}

func TestGetByID(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()
	initUser := &models.User{
		Username:     "testuser_for_id",
		Email:        "getid@example.com",
		PasswordHash: "passwordHash",
	}
	createdUser, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)

	foundUser, err := testUserStore.GetByID(ctx, createdUser.ID)
	require.NoError(t, err, "アイディが存在する場合、エラーを返すべきではありません")
	require.NotNil(t, foundUser, "見つかったユーザーは空であるべきではありません")
	assert.Equal(t, createdUser.ID, foundUser.ID, "見つかったユーザーIDが一致するべきです")
	assert.Equal(t, createdUser.Username, foundUser.Username, "見つかったユーザー名が一致するべきです")
	assert.Equal(t, createdUser.Email, foundUser.Email, "見つかったメールアドレスが一致するべきです")
	assert.Equal(t, createdUser.PasswordHash, foundUser.PasswordHash, "見つかったPasswordHashが一致するべきです")
	assert.True(t, createdUser.CreatedAt.Equal(foundUser.CreatedAt), "CreatedAtは一致するべきです")
}

func TestGetByIDWhlieError(t *testing.T) {
	testContext.CleanupTestDB()
	defer testContext.CleanupTestDB()
	ctx := context.Background()
	initUser := &models.User{
		Username:     "testuser_for_id",
		Email:        "getid@example.com",
		PasswordHash: "passwordHash",
	}
	_, err := testUserStore.Create(ctx, initUser)
	require.NoError(t, err)
	t.Run("ユーザーが存在しない", func(t *testing.T) {
		unfoundUser, err := testUserStore.GetByID(ctx, 99999)
		assert.ErrorIs(t, err, errcode.ErrUserNotFound, "エラーはErrNotFound であるべきです")
		assert.Nil(t, unfoundUser, "見つかったユーザーオブジェクトは空であるべきです")
	})

	t.Run("データベース切断時の時、ラップされたエラーを返すこと", func(t *testing.T) {
		tempDB, err := testutils.OpenDB(testContext.DSN)
		require.NoError(t, err)

		tempUserStore := NewPostgresUserStore(tempDB)
		tempDB.Close()

		unfoundUser, err := tempUserStore.GetByID(ctx, 1)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "IDによるユーザー取得に失敗しました")
		t.Logf("エラーは: %v\n", err)
		assert.Nil(t, unfoundUser)
	})
}
</file>

<file path="internal/models/session.go">
package models

import(
	"time"
)


type Session struct{
	ID            int64        `db:"id"`
	UserID        int64        `db:"user_id"`
	TokenHash     string       `db:"token_hash"`
	ExpiresAt     time.Time    `db:"expires_at"`
	CreatedAt     time.Time    `db:"created_at"`
}

func(s *Session) IsExpired() bool {
	if s == nil {
		return true
	}

	now := time.Now().UTC()
	if now.After(s.ExpiresAt.UTC()) {
		return true
	}
	maxAge := MaxSessionLife
	if now.After(s.CreatedAt.UTC().Add(maxAge)) {
		return true
	}
	return false
}

func (s *Session) ShouldRefresh() bool {
	if s == nil || s.IsExpired(){
		return false
	}

	totalDuration := s.ExpiresAt.UTC().Sub(s.CreatedAt.UTC())
	remaining := s.ExpiresAt.UTC().Sub(time.Now().UTC())

	if totalDuration <= 0 {
		return true
	}
	return remaining < totalDuration / 4
}
</file>

<file path="internal/models/user.go">
package models

import (
	"time"
)

type User struct{
	ID            int64        `db:"id"`
	Username      string       `db:"username"`
	Email         string       `db:"email"`
	PasswordHash  string       `db:"password_hash"`
	CreatedAt     time.Time    `db:"created_at"`
}
</file>

<file path="internal/pkg/testutils/testdb.go">
package testutils

import (
	"aita/internal/configuration"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"testing"

	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

type TestContext struct {
	TestDB *sqlx.DB
	DSN string
}

// データベースのオフライン状態を擬似的に再現する
func OpenDB(dsn string) (*sqlx.DB, error) {
	db, err := sqlx.Open("postgres", dsn)
	if err != nil {
		return nil, err
	}
	if err := db.Ping(); err != nil {
		return nil, err
	}
	return db, err
}
func  (ctx *TestContext) CleanupTestDB() {
	_, err := ctx.TestDB.Exec(`TRUNCATE TABLE sessions, tweets, users RESTART IDENTITY CASCADE;`)
	if err != nil {
		log.Fatalf("テストデータベースに接続できません: %v", err)
	}
}
func RunTestMain(m *testing.M) (*TestContext, func()) {
	os.Setenv("APP_ENV", "test")

	cfg := configuration.LoadConfig()

	db, err := sqlx.Connect("postgres", cfg.DBConnStr)
	if err != nil {
		log.Fatalf("テストデータベースに接続できません (%.50s...): %v", cfg.DBConnStr, err)
	}

	migrationDir := configuration.GetPath("migrations")
	absPath, _ := filepath.Abs(migrationDir)
	cleanPath :=  filepath.ToSlash(absPath)

	var migrationURL string

	if runtime.GOOS == "windows" {
		migrationURL = "file://" + strings.TrimPrefix(cleanPath, "/")
	} else {
		migrationURL = "file://" + cleanPath
	}
	log.Printf("Migration URL: %s", migrationURL)

	mig, err := migrate.New(
        migrationURL, 
        cfg.DBConnStr,
    )
	if err != nil {
        log.Fatalf("マイグレーションインスタンスの生成に失敗しました: %v", err)
    }
	if err := mig.Up(); err != nil && err != migrate.ErrNoChange  {
		log.Fatalf("マイグレーションの実行に失敗しました: %v", err)
	}
	teardown := func() {
		srcErr, dbErr := mig.Close()
		if srcErr != nil || dbErr != nil {
			log.Printf("マイグレーションインスタンスの停止に失敗しました: %v, %v", srcErr, dbErr)
		}
		db.Close()
	}
	return &TestContext{
		TestDB: db,
		DSN:    cfg.DBConnStr,
	}, teardown
}
</file>

<file path="internal/service/mock_service_test.go">
package service

import (
	"aita/internal/models"
	"aita/internal/pkg/testutils"
	"context"
	"errors"
	"time"

	"github.com/stretchr/testify/mock"
)

var (
    errMockInternal = errors.New("接続拒否")
    errMockHashFailed = errors.New("暗号化内部エラー")
	errMockTokenFailed = errors.New("トークン内部エラー")
)

type mockUserStore struct {
	mock.Mock
}

func (m *mockUserStore) Create(ctx context.Context, user *models.User) (*models.User, error) {
	args := m.Called(ctx, user)
	return testutils.SafeGet[models.User](args, 0), args.Error(1)
}

func (m *mockUserStore) GetByEmail(ctx context.Context, email string) (*models.User, error) {
	args := m.Called(ctx, email)
	return testutils.SafeGet[models.User](args,0), args.Error(1)
}

func (m *mockUserStore) GetByID(ctx context.Context, id int64) (*models.User, error) {
	args := m.Called(ctx, id)
	return testutils.SafeGet[models.User](args,0), args.Error(1)
}

type mockSessionStore struct {
	mock.Mock
}

func (m *mockSessionStore) Create(ctx context.Context, session *models.Session) (*models.Session, error) {
	args := m.Called(ctx, session)
	return testutils.SafeGet[models.Session](args, 0), args.Error(1)
}

func(m *mockSessionStore) GetByHash(ctx context.Context, tokenHash string) (*models.Session, error) {
	args := m.Called(ctx, tokenHash)
	return testutils.SafeGet[models.Session](args, 0), args.Error(1)
}

func(m *mockSessionStore) UpdateExpiresAt(ctx context.Context, expiresAt time.Time, id int64) error {
	args := m.Called(ctx, expiresAt, id)
	return args.Error(0)
}

func(m *mockSessionStore) DeleteBySessionID(ctx context.Context, sessionID int64) error {
	args := m.Called(ctx,sessionID)
	return args.Error(0)
}

type mockTweetStore struct {
	mock.Mock
}

func (m *mockTweetStore) CreateTweet(ctx context.Context, twt *models.Tweet) (*models.Tweet, error) {
	args := m.Called(ctx, twt)
	return testutils.SafeGet[models.Tweet](args, 0), args.Error(1)
}

func(m *mockTweetStore) GetTweetByTweetID(ctx context.Context, tweetID int64) (*models.Tweet, error) {
	args := m.Called(ctx, tweetID)
	return testutils.SafeGet[models.Tweet](args, 0), args.Error(1)
}

func(m *mockTweetStore) UpdateContent(ctx context.Context, newContent string,  tweetID int64) (*models.Tweet, error) {
	args := m.Called(ctx, newContent, tweetID)
	return testutils.SafeGet[models.Tweet](args, 0), args.Error(1)
}


func(m *mockTweetStore) DeleteTweet(ctx context.Context, tweetID int64) error {
	args := m.Called(ctx, tweetID)
	return args.Error(0)
}

type mockBcryptHasher struct {
	mock.Mock
}

func (m *mockBcryptHasher) Generate(password string) (string, error) {
	args := m.Called(password)
	return args.String(0), args.Error(1)
}

func(m *mockBcryptHasher) Compare(hashedPassword, password string) error {
	args := m.Called(hashedPassword, password)
	return args.Error(0)
}

type mockTokenManager struct {
	mock.Mock
}

func(m *mockTokenManager) Generate(length int) (string, error) {
	args := m.Called(length)
	return args.String(0), args.Error(1)
}

func(m *mockTokenManager) Hash(hash string) string {
	args := m.Called(hash)
	return args.String(0)
}

type mockUserService struct {
	mock.Mock
}

func (m *mockUserService) ToMyPage(ctx context.Context, userID int64) (*models.User, error) {
	args := m.Called(ctx, userID)
	return testutils.SafeGet[models.User](args, 0), args.Error(1)
}
</file>

<file path="internal/service/tweet_service.go">
package service

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"context"
	"fmt"
)

type TweetStore interface {
	CreateTweet(ctx context.Context, tweet *models.Tweet) (*models.Tweet, error)
	GetTweetByTweetID(ctx context.Context, tweetID int64) (*models.Tweet, error)
	UpdateContent(ctx context.Context, newContent string, tweetID int64) (*models.Tweet,error)
	DeleteTweet(ctx context.Context, tweetID int64) error
}

type tweetService struct {
	tweetStore TweetStore
}

func NewTweetService(ts TweetStore) *tweetService {
	return &tweetService{tweetStore: ts}
}

func (s *tweetService) PostTweet(ctx context.Context, userID int64, content string, imageURL *string) (*models.Tweet, error) {
	if userID <= 0 {
		return nil, errcode.ErrInvalidUserID
	}

	if content == "" {
        return nil, errcode.ErrRequiredFieldMissing
    }

	initialTweet := &models.Tweet{
		UserID:   userID,
		Content:  content,
		ImageURL: imageURL,
	}
	
	savedTweet, err := s.tweetStore.CreateTweet(ctx, initialTweet)
	if err != nil {
		return nil, fmt.Errorf("ツイートの挿入に失敗しました: %w", err)
	}
	return savedTweet, nil
}

func (s *tweetService) FetchTweet(ctx context.Context, tweetID int64) (*models.Tweet, error) {
	if tweetID <= 0 {
		return nil, errcode.ErrInvalidTweetID
	}

	tweet, err := s.tweetStore.GetTweetByTweetID(ctx, tweetID)

	if err != nil {
		return nil, fmt.Errorf("ツイート情報の取得に失敗しました: %w", err)
	}

	return tweet, nil
}

func (s *tweetService) ToMyTweet(ctx context.Context, tweetID int64, userID int64) (*models.Tweet, error) {
	if userID <= 0 {
		return nil, errcode.ErrInvalidUserID
	}

	tweet, err := s.FetchTweet(ctx, tweetID)
	if err != nil {
		return nil, err
	}

	if tweet.UserID != userID {
		return nil, errcode.ErrForbidden
	}

	return tweet, nil
}

func (s *tweetService) EditTweet(ctx context.Context, newContent string, tweetID int64, userID int64) (*models.Tweet, bool, error) {
	if userID <= 0 {
		return nil, false, errcode.ErrInvalidUserID
	}

	if  newContent == "" {
		return nil, false, errcode.ErrRequiredFieldMissing
	}
	tweet, err := s.ToMyTweet(ctx, tweetID, userID)
	if err != nil {
		return nil, false, err
	}

	if tweet.Content == newContent {
		return tweet, false, nil
	}

	if !tweet.CanBeUpdated() {
		return nil, false, errcode.ErrEditTimeExpired
	}

	tweet, err = s.tweetStore.UpdateContent(ctx, newContent, tweetID)

	if err != nil {
		return nil, false, fmt.Errorf("ツイート編集に失敗しました: %w", err)
	}

	return tweet, true, nil
}

func (s *tweetService) RemoveTweet(ctx context.Context, tweetID int64, userID int64) error {
	if userID <= 0 {
		return errcode.ErrInvalidUserID
	}
	_, err := s.ToMyTweet(ctx, tweetID, userID)
	if err != nil {
		return err
	}

	err = s.tweetStore.DeleteTweet(ctx, tweetID)
	if err != nil {
		return fmt.Errorf("ツイートの削除に失敗しました: %w", err)
	}

	return nil
}
</file>

<file path="migrations/000001_create_initial_tables.up.sql">
-- users table
CREATE TABLE "users"(
    "id" bigserial PRIMARY KEY,
    "username" varchar(50) UNIQUE NOT NULL,
    "email" varchar(255) UNIQUE NOT NULL,
    "password_hash" varchar(255) NOT NULL,
    "created_at" timestamptz NOT NULL DEFAULT (now())
);
--tweets table
CREATE TABLE "tweets"(
    "id" bigserial PRIMARY KEY,
    "user_id" bigint NOT NULL,
    "content" text NOT NULL,
    "image_url" varchar(255),
    "created_at" timestamptz NOT NULL DEFAULT(now())
);
--sessions table
CREATE TABLE "sessions" (
    "id" bigserial PRIMARY KEY,
    "user_id" bigint NOT NULL,
    "token_hash" varchar(255) UNIQUE NOT NULL,
    "expires_at" timestamptz NOT NULL 
);
ALTER TABLE "tweets" ADD FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE CASCADE;
ALTER TABLE "sessions" ADD FOREIGN KEY ("user_id") REFERENCES "users"("id") ON DELETE CASCADE;
</file>

<file path="go.mod">
module aita

go 1.25.1

require (
	github.com/gin-gonic/gin v1.11.0
	github.com/go-playground/validator/v10 v10.27.0
	github.com/golang-migrate/migrate/v4 v4.19.1
	github.com/jmoiron/sqlx v1.4.0
	github.com/joho/godotenv v1.5.1
	github.com/lib/pq v1.10.9
	github.com/stretchr/testify v1.11.1
	golang.org/x/crypto v0.45.0
)

require (
	github.com/bytedance/sonic v1.14.0 // indirect
	github.com/bytedance/sonic/loader v0.3.0 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/cloudwego/base64x v0.1.6 // indirect
	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/goccy/go-json v0.10.2 // indirect
	github.com/goccy/go-yaml v1.18.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.3.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
	github.com/quic-go/qpack v0.5.1 // indirect
	github.com/quic-go/quic-go v0.54.0 // indirect
	github.com/redis/go-redis/v9 v9.17.3 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.3.0 // indirect
	go.uber.org/mock v0.5.0 // indirect
	golang.org/x/arch v0.20.0 // indirect
	golang.org/x/mod v0.29.0 // indirect
	golang.org/x/net v0.47.0 // indirect
	golang.org/x/sync v0.18.0 // indirect
	golang.org/x/sys v0.38.0 // indirect
	golang.org/x/text v0.31.0 // indirect
	golang.org/x/tools v0.38.0 // indirect
	google.golang.org/protobuf v1.36.9 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
</file>

<file path="internal/api/middleware.go">
package api

import (
	"aita/internal/contextkeys"
	"aita/internal/dto"
	"aita/internal/errcode"
	"aita/internal/models"
	"context"

	"github.com/gin-gonic/gin"
)

type AuthSessionService interface {
	Validate(ctx context.Context, token string) (*models.Session, error)
}

func AuthMiddleware(svc AuthSessionService) gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		token, err := extractBearerToken(authHeader)
		if err != nil {
			c.AbortWithStatusJSON(dto.GetStatusCode(err), dto.Fail(err))
			return
		}
		session, err := svc.Validate(c.Request.Context(), token)
		if err != nil {
			c.AbortWithStatusJSON(dto.GetStatusCode(err), dto.Fail(err))
			return
		}

		if session == nil {
			err := errcode.ErrSessionNotFound
			c.AbortWithStatusJSON(dto.GetStatusCode(err), dto.Fail(err))
			return
		}

		c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{
			UserID: session.UserID,
			SessionID: session.ID,
		})
		c.Next()
	}
}
</file>

<file path="internal/api/tweet_handler.go">
package api

import (
	"aita/internal/dto"
	"aita/internal/models"
	"context"
	"net/http"

	"github.com/gin-gonic/gin"
)

type TweetService interface {
	PostTweet(ctx context.Context, userID int64, content string, imageURL *string) (*models.Tweet, error)
	FetchTweet(ctx context.Context, tweetID int64) (*models.Tweet, error) 
	EditTweet(ctx context.Context, newContent string, tweetID int64, userID int64) (*models.Tweet, bool, error)
	RemoveTweet(ctx context.Context, tweetID int64, userID int64) error
}

type TweetHandler struct {
	tweetService TweetService
}

func NewTweetHandler(svc TweetService) *TweetHandler {
	return &TweetHandler{tweetService: svc}
}

func (h *TweetHandler) Create(c *gin.Context) {
	auth, err := GetAuthContext(c)
    if err != nil {
        c.JSON(dto.GetStatusCode(err), dto.Fail(err))
        return
    }

	var req dto.CreateTweetRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		appErr := dto.FilterBindError(err)
		c.JSON(dto.GetStatusCode(appErr), dto.Fail(appErr))
		return
	}

	if err := req.Validate(); err != nil {
        c.JSON(dto.GetStatusCode(err), dto.Fail(err))
        return
    }


	tweet, err := h.tweetService.PostTweet(
        c.Request.Context(), 
        auth.UserID,    
        req.Content,    
        req.ImageURL,
    )
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}

	c.JSON(http.StatusCreated, dto.Success(dto.NewTweetResponse(tweet)))
}

func (h *TweetHandler) Get(c *gin.Context) {
	id, err := GetIDParam(c, "id")
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return 
	}

	tweet, err := h.tweetService.FetchTweet(c.Request.Context(), id)
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return 
	}
	c.JSON(http.StatusOK, dto.Success(dto.NewTweetResponse(tweet)))

}
func (h *TweetHandler) Update(c *gin.Context) {
	id, err := GetIDParam(c, "id")
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return 
	}
	auth, err := GetAuthContext(c)
    if err != nil {
        c.JSON(dto.GetStatusCode(err), dto.Fail(err))
        return
    }
	var req dto.UpdateTweetRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		appErr := dto.FilterBindError(err)
		c.JSON(dto.GetStatusCode(appErr), dto.Fail(appErr))
		return
	}

	if err := req.Validate(); err != nil {
        c.JSON(dto.GetStatusCode(err), dto.Fail(err))
        return
    }
	tweet, isChanged, err := h.tweetService.EditTweet(c.Request.Context(), req.Content, id, auth.UserID)
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}

	if ! isChanged {
		c.JSON(http.StatusOK, dto.SuccessMsg("内容に変更はありません"))
        return
	}

	c.JSON(http.StatusOK, dto.Success(dto.NewTweetResponse(tweet)))

}
func (h *TweetHandler) Delete(c *gin.Context) {
	id, err := GetIDParam(c, "id")
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return 
	}
	auth, err := GetAuthContext(c)
    if err != nil {
        c.JSON(dto.GetStatusCode(err), dto.Fail(err))
        return
    }
	err = h.tweetService.RemoveTweet(c.Request.Context(), id, auth.UserID)
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return 
	}
	
	c.JSON(http.StatusOK, dto.SuccessMsg("ツイートの削除成功"))
}
</file>

<file path="internal/api/user_handler_test.go">
package api

import (
	"aita/internal/contextkeys"
	"aita/internal/dto"
	"aita/internal/errcode"
	"aita/internal/models"
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

func TestSignUp(t *testing.T) {
	gin.SetMode(gin.TestMode)
	tests := []struct {
		name           string
		requestBody    any
		setupMock      func(mu *mockUserService, ms *mockSessionService)
		expectedStatus int
		checkResponse  func(t *testing.T, w *httptest.ResponseRecorder)
	}{
		{
			name: "ユーザー登録成功",
			requestBody: dto.SignupRequest{
				Username: "mock_user",
				Email:    "taro@example.com",
				Password: "password123",
			},
			setupMock: func(mu *mockUserService, ms *mockSessionService) {
				user := &models.User{
					ID: 1,
					Username: "mock_User",
					Email: "taro@example.com",
					PasswordHash: "password123hash",
					CreatedAt: time.Now().UTC(),
				}
				mu.On("Register", mock.Anything, mock.MatchedBy(func(username string) bool {
					return username == "mock_user"
				}), mock.MatchedBy(func(email string) bool{
					return email == "taro@example.com"
				}), mock.MatchedBy(func(password string) bool {
					return password == "password123"
				})).Return(user, nil)
				ms.On("Issue", mock.Anything, user.ID).Return("valid_token_string", nil)
			},
			expectedStatus: http.StatusCreated,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				data := resp.Data.(map[string]any)
				assert.Equal(t, "valid_token_string", data["session_token"])
			},
		},
		{
			name:           "リクエスト形式不正: 無効なJSONを送信した場合",
			requestBody:    `{"username": "incomplete_json`,
			setupMock:      func(mu *mockUserService, ms *mockSessionService) {},
			expectedStatus: http.StatusBadRequest,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)

				assert.Equal(t, "INVALID_JSON_FORMAT", resp.Code)
				assert.Equal(t, "JSONの構文が正しくありません", resp.Error)
			},
		},
		{
			name: "バリデーションエラー：メールアドレス重複",
			requestBody: dto.SignupRequest{
				Username: "mock_user",
				Email:    "exists@example.com",
				Password: "password123",
			},
			setupMock: func(mu *mockUserService, ms *mockSessionService) {
				mu.On("Register", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(nil, errcode.ErrEmailConflict)
			},
			expectedStatus: http.StatusConflict,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)

				assert.Equal(t, "EMAIL_CONFLICT", resp.Code)
				assert.Contains(t, resp.Error, "既に使用されています")
			},
		},
		{
			name: "セッション発行失敗",
			requestBody: dto.SignupRequest{
				Username: "error_user",
				Email:    "issue_fail@test.com",
				Password: "password123",
			},
			setupMock: func(mu *mockUserService, ms *mockSessionService) {
				user := &models.User{
					ID: 50, 
					Username: "error_user",
					Email:    "issue_fail@test.com",
					PasswordHash: "password123hashed",
					CreatedAt: time.Now().UTC(),
				}
				mu.On("Register", mock.Anything, mock.MatchedBy(func(username string) bool {
					return username == "error_user"
				}), mock.MatchedBy(func(email string) bool{
					return email == "issue_fail@test.com"
				}), mock.MatchedBy(func(password string) bool {
					return password == "password123"
				})).Return(user, nil)
				ms.On("Issue", mock.Anything, int64(50)).Return("", errors.New("redis connection failed"))
			},
			expectedStatus: http.StatusInternalServerError,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				assert.Equal(t, "INTERNAL_SERVER_ERROR", resp.Code)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mu, ms := new(mockUserService), new(mockSessionService)
			h := NewUserHandler(mu, ms)
			tt.setupMock(mu, ms)

			var buf bytes.Buffer
			if s, ok := tt.requestBody.(string); ok {
				buf.WriteString(s)
			} else {
				json.NewEncoder(&buf).Encode(tt.requestBody)
			}

			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)
			c.Request = httptest.NewRequest(http.MethodPost, "/signup", &buf)

			h.SignUp(c)

			assert.Equal(t, tt.expectedStatus, w.Code)
			if tt.checkResponse != nil {
				tt.checkResponse(t, w)
			}
		})
	}
}

func TestLogin(t *testing.T) {
	gin.SetMode(gin.TestMode)
	tests := []struct {
		name           string
		requestBody    any
		setupMock      func(mu *mockUserService, ms *mockSessionService)
		expectedStatus int
		checkResponse  func(t *testing.T, w *httptest.ResponseRecorder)
	}{
		{
			name: "ログイン成功",
			requestBody: dto.LoginRequest{
				Email:    "test@example.com",
				Password: "password123",
			},
			setupMock: func(mu *mockUserService, ms *mockSessionService) {
				user := &models.User{ID: 1, Email: "test@example.com"}
				mu.On("Login", mock.Anything, "test@example.com", "password123").Return(user, nil)
				ms.On("Issue", mock.Anything, user.ID).Return("login_token_abc", nil)
			},
			expectedStatus: http.StatusOK,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				data := resp.Data.(map[string]any)
				assert.Equal(t, "login_token_abc", data["session_token"])
			},
		},
		{
			name:           "JSON構文エラー",
			requestBody:    `{"email": "bad-json"...`,
			setupMock:      func(mu *mockUserService, ms *mockSessionService) {},
			expectedStatus: http.StatusBadRequest,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				assert.Equal(t, "INVALID_JSON_FORMAT", resp.Code)
			},
		},
		{
			name: "メールアドレスまたはパスワードが間違っている場合",
			requestBody: dto.LoginRequest{
				Email:    "wrong@example.com",
				Password: "wrongpassword",
			},
			setupMock: func(mu *mockUserService, ms *mockSessionService) {
				mu.On("Login", mock.Anything, mock.Anything, mock.Anything).Return(nil, errcode.ErrInvalidCredentials)
			},
			expectedStatus: http.StatusUnauthorized,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				assert.Equal(t, "INVALID_CREDENTIALS", resp.Code)
				assert.Contains(t, resp.Error, "正しくありません")
			},
		},
		{
			name: "トークン発行失敗",
			requestBody: dto.LoginRequest{
				Email:    "test@example.com",
				Password: "password123",
			},
			setupMock: func(mu *mockUserService, ms *mockSessionService) {
				user := &models.User{ID: 1, Email: "test@example.com"}
				mu.On("Login", mock.Anything, "test@example.com", "password123").Return(user, nil)
				ms.On("Issue", mock.Anything, user.ID).Return("", errors.New("internal server error"))
			},
			expectedStatus: http.StatusInternalServerError,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				assert.Equal(t, "INTERNAL_SERVER_ERROR", resp.Code)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mu, ms := new(mockUserService), new(mockSessionService)
			h := NewUserHandler(mu, ms)
			tt.setupMock(mu, ms)

			var buf bytes.Buffer
			if s, ok := tt.requestBody.(string); ok {
				buf.WriteString(s)
			} else {
				json.NewEncoder(&buf).Encode(tt.requestBody)
			}

			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)
			c.Request = httptest.NewRequest(http.MethodPost, "/login", &buf)

			h.Login(c)

			assert.Equal(t, tt.expectedStatus, w.Code)
			if tt.checkResponse != nil {
				tt.checkResponse(t, w)
			}
		})
	}
}

func TestGetMe(t *testing.T) {
	gin.SetMode(gin.TestMode)
	tests := []struct {
		name           string
		setupContext   func(c *gin.Context)
		setupMock      func(mu *mockUserService)
		expectedStatus int
		checkResponse  func(t *testing.T, w *httptest.ResponseRecorder)
	}{
		{
			name: "マイページ取得成功",
			setupContext: func(c *gin.Context) {
				c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{UserID: 101, SessionID: 104})
			},
			setupMock: func(mu *mockUserService) {
				user := &models.User{ID: 101, Username: "test_user", Email: "test@example.com"}
				mu.On("ToMyPage", mock.Anything, int64(101)).Return(user, nil)
			},
			expectedStatus: http.StatusOK,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				data := resp.Data.(map[string]any)
				assert.Equal(t, "test_user", data["username"])
				assert.EqualValues(t, 101, data["id"])
			},
		},
		{
			name:           "未認証エラー",
			setupContext:   func(c *gin.Context) {},
			setupMock:      func(mu *mockUserService) {},
			expectedStatus: http.StatusUnauthorized,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				assert.Equal(t, "SESSION_NOT_FOUND", resp.Code)
			},
		},
		{
			name: "ユーザー不在",
			setupContext: func(c *gin.Context) {
				c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{UserID: 404, SessionID: 104})
			},
			setupMock: func(mu *mockUserService) {
				mu.On("ToMyPage", mock.Anything, int64(404)).Return(nil, errcode.ErrUserNotFound)
			},
			expectedStatus: http.StatusNotFound,
			checkResponse: func(t *testing.T, w *httptest.ResponseRecorder) {
				var resp dto.Response
				json.Unmarshal(w.Body.Bytes(), &resp)
				assert.Equal(t, "USER_NOT_FOUND", resp.Code)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mu := new(mockUserService)
			h := NewUserHandler(mu, nil)
			tt.setupMock(mu)

			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)
			c.Request, _ = http.NewRequest(http.MethodGet, "/me", nil)
			tt.setupContext(c)

			h.GetMe(c)

			assert.Equal(t, tt.expectedStatus, w.Code)
			if tt.checkResponse != nil {
				tt.checkResponse(t, w)
			}
			mu.AssertExpectations(t)
		})
	}
}

func TestUserHandlerLogout(t *testing.T) {

    gin.SetMode(gin.TestMode)

    const testSessionID int64 = 999

    tests := []struct {
        name           string
        setupContext   func(c *gin.Context)
        setupMock      func(ms *mockSessionService)
        expectedStatus int
        expectMsg      string
    }{
        {
            name: "ログアウト成功",
            setupContext: func(c *gin.Context) {
                c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{
                    SessionID: testSessionID,
                })
            },
            setupMock: func(ms *mockSessionService) {
                ms.On("Revoke", mock.Anything, testSessionID).Return(nil)
            },
            expectedStatus: http.StatusOK,
            expectMsg:      "ログアウトしました",
        },
        {
            name: "セッションが見たからない",
            setupContext: func(c *gin.Context) {},
            setupMock:      func(ms *mockSessionService) {},
            expectedStatus: http.StatusUnauthorized,
        },
        {
            name: "サーバー内部エラー",
            setupContext: func(c *gin.Context) {
                c.Set(contextkeys.AuthPayloadKey, &dto.AuthContext{
                    SessionID: testSessionID,
                })
            },
            setupMock: func(ms *mockSessionService) {
                ms.On("Revoke", mock.Anything, testSessionID).Return(errcode.ErrSessionNotFound)
            },
            expectedStatus: http.StatusUnauthorized,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            
			ms := new(mockSessionService)
			h := NewUserHandler(nil, ms)
			
			tt.setupMock(ms)

            w := httptest.NewRecorder()
            c, _ := gin.CreateTestContext(w)

            c.Request, _ = http.NewRequest(http.MethodPost, "/logout", nil)
        
            tt.setupContext(c)

            h.Logout(c)

            assert.Equal(t, tt.expectedStatus, w.Code)
            if tt.expectMsg != "" {
                assert.Contains(t, w.Body.String(), tt.expectMsg)
            }

            ms.AssertExpectations(t)
        })
    }
}
</file>

<file path="internal/db/main_store_test.go">
package db

import (
	"aita/internal/pkg/testutils"
	"log"
	"os"
	"testing"
)


var (
    testUserStore    *postgresUserStore
    testSessionStore *postgresSessionStore
    testTweetStore   *postgresTweetStore
    testContext      *testutils.TestContext 
)

func TestMain(m *testing.M) {
	tc, teardown := testutils.RunTestMain(m)
	testContext = tc
    log.Println("Migration successful!")
	testUserStore = NewPostgresUserStore(testContext.TestDB)
	testSessionStore = NewPostgresSessionStore(testContext.TestDB)
	testTweetStore = NewPostgresTweetStore(testContext.TestDB)
	testContext.CleanupTestDB()
	exitCode := m.Run()
	teardown()
	os.Exit(exitCode)
}
</file>

<file path="internal/db/user_store.go">
package db

import (
	"aita/internal/errcode"
	"aita/internal/models"
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

type postgresUserStore struct {
	database *sqlx.DB
}

func NewPostgresUserStore(DB *sqlx.DB) *postgresUserStore {
	return &postgresUserStore{database: DB}
}

func (s *postgresUserStore) Create(ctx context.Context, user *models.User) (*models.User, error) {
	query := `INSERT INTO users(username, email, password_hash) 
			  VALUES ($1, $2, $3) 
			  RETURNING id, username, email, password_hash, created_at`

	var newUser models.User
	err := s.database.QueryRowContext(
		ctx,
		query,
		user.Username,
		user.Email,
		user.PasswordHash,
	).Scan(
		&newUser.ID,
		&newUser.Username,
		&newUser.Email,
		&newUser.PasswordHash,
		&newUser.CreatedAt,
	)

	if err != nil {
		var pqErr *pq.Error
		if errors.As(err, &pqErr) {
			switch pqErr.Code {
			case errCodeUniqueViolation:
				switch pqErr.Constraint {
				case constraintUsernameK:
					return nil, errcode.ErrUsernameConflict
				case constraintUseremailK:
					return nil, errcode.ErrEmailConflict
				}
			case errCodeStringDataRightTruncation:
				return nil, errcode.ErrValueTooLong
			}
		}
		return nil, fmt.Errorf("ユーザーの生成に失敗しました: %w", err)
	}

	newUser.CreatedAt = newUser.CreatedAt.UTC()
	return &newUser, nil
}

func (s *postgresUserStore) GetByEmail(ctx context.Context, email string) (*models.User, error) {
	var newUser models.User
	query := `SELECT id, username, email, password_hash, created_at FROM users WHERE email = $1`
	err := s.database.GetContext(ctx, &newUser, query, email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, errcode.ErrUserNotFound
		}
		return nil, fmt.Errorf("emailによるユーザー取得に失敗しました: %w", err)
	}

	newUser.CreatedAt = newUser.CreatedAt.UTC()
	return &newUser, nil
}

func (s *postgresUserStore) GetByID(ctx context.Context, id int64) (*models.User, error) {
	var newUser models.User
	query := `SELECT id, username, email, password_hash,created_at FROM users WHERE id = $1`
	err := s.database.GetContext(ctx, &newUser, query, id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, errcode.ErrUserNotFound
		}
		return nil, fmt.Errorf("userIDによるユーザー取得に失敗しました: %w", err)
	}

	newUser.CreatedAt = newUser.CreatedAt.UTC()
	return &newUser, nil
}
</file>

<file path="tests/main_test.go">
package tests

import (
	"aita/internal/db"
	"aita/internal/pkg/crypto"
	"aita/internal/pkg/testutils"
	"aita/internal/service"
	"log"
	"os"
	"testing"

	"golang.org/x/crypto/bcrypt"
)

var (
	testUserStore    service.UserStore       
	testSessionStore service.SessionStore
	testTweetStore   service.TweetStore
	testTokemanager  service.TokenManager
	testHasher       service.PasswordHasher
	testContext      *testutils.TestContext
)

func TestMain(m *testing.M) {
	tc, teardown := testutils.RunTestMain(m)
	testContext = tc
	log.Println("Database migration successful!")

	testHasher = crypto.NewBcryptHasher(bcrypt.DefaultCost)
	testTokemanager = crypto.NewTokenManager()

	testUserStore = db.NewPostgresUserStore(testContext.TestDB)
	testSessionStore = db.NewPostgresSessionStore(testContext.TestDB)
	testTweetStore = db.NewPostgresTweetStore(testContext.TestDB)
	
	
    testContext.CleanupTestDB()

	exitCode := m.Run()

	teardown()
	os.Exit(exitCode)
}
</file>

<file path="tests/user_flow_test.go">
package tests

import (
	"aita/internal/api"
	"aita/internal/dto"
	"aita/internal/service"
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestUserLifeCycleIntegration(t *testing.T) {
	testContext.CleanupTestDB()
	userService := service.NewUserService(testUserStore, testHasher)
	sessionService := service.NewSessionService(testSessionStore, userService, testTokemanager)
	tweetService := service.NewTweetService(testTweetStore)
	userHandler := api.NewUserHandler(userService, sessionService)
	tweetHandler := api.NewTweetHandler(tweetService)

	gin.SetMode(gin.TestMode)
	r := api.SetupRouter(userHandler, tweetHandler, sessionService)
	signupPayload := dto.SignupRequest{
		Username: "frontend_dev",
		Email:    "dev@aita.com",
		Password: "password123",
	}
	jsonSignup, _ := json.Marshal(signupPayload)
	w := httptest.NewRecorder()
	req, _ := http.NewRequest(http.MethodPost, "/api/v1/signup", bytes.NewBuffer(jsonSignup))
	req.Header.Set("Content-Type", "application/json")
	r.ServeHTTP(w, req)
	assert.Equal(t, http.StatusCreated, w.Code)
	assert.Contains(t, w.Body.String(), "frontend_dev")

	loginPayload := dto.LoginRequest{
		Email:    "dev@aita.com",
		Password: "password123",
	}
	jsonLogin, _ := json.Marshal(loginPayload)
	w = httptest.NewRecorder()
	req, _ = http.NewRequest(http.MethodPost, "/api/v1/login", bytes.NewBuffer(jsonLogin))
	r.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code)

	var loginResp struct {
		Data struct {
			Token string `json:"session_token"`
		} `json:"data"`
	}
	err := json.Unmarshal(w.Body.Bytes(), &loginResp)
	require.NoError(t, err)
	token := loginResp.Data.Token
	require.NotEmpty(t, token)

	w = httptest.NewRecorder()
	req, _ = http.NewRequest(http.MethodGet, "/api/v1/me", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	r.ServeHTTP(w, req)
	assert.Equal(t, http.StatusOK, w.Code)
	fmt.Println("Body:", w.Body.String())
	assert.Contains(t, w.Body.String(), "frontend_dev")

	w = httptest.NewRecorder()
	req, _ = http.NewRequest(http.MethodGet, "/api/v1/me", nil)
	r.ServeHTTP(w, req)
	assert.Equal(t, http.StatusUnauthorized, w.Code)
}
</file>

<file path="internal/api/router.go">
package api

import (
	"github.com/gin-gonic/gin"
)

func SetupRouter(
	userHandler *UserHandler, 
	tweetHandler *TweetHandler, 
	sessionService AuthSessionService ,
) *gin.Engine {
	router := gin.Default()
	router.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "ok"})
    })
	
	v1 := router.Group("/api/v1")
	{
		v1.POST("/signup", userHandler.SignUp)
		v1.POST("/login", userHandler.Login)
		v1.GET("/tweets/:id", tweetHandler.Get)
		protected := v1.Group("/")
		protected.Use(AuthMiddleware(sessionService))
		{
			protected.GET("/me", userHandler.GetMe)
			protected.POST("/logout", userHandler.Logout)
			tweets := protected.Group("/tweets")
			{
				tweets.POST("", tweetHandler.Create)
				tweets.PATCH("/:id", tweetHandler.Update)  
                tweets.DELETE("/:id", tweetHandler.Delete)
			}
		} 
	}
	return router
}
</file>

<file path="internal/api/user_handler.go">
package api

import (
	"aita/internal/dto"
	"aita/internal/models"
	"context"

	"net/http"

	"github.com/gin-gonic/gin"
)

type UserService interface {
	Register(ctx context.Context, username string, email string, password string) (*models.User, error) 
	Login(ctx context.Context, email, password string) (*models.User, error)
	ToMyPage(ctx context.Context, id int64) (*models.User, error)
}

type SessionManager interface {
	Issue(ctx context.Context, userID int64) (string, error)
	Revoke(ctx context.Context, sessionID int64) error 
}

type UserHandler struct {
	userService    UserService
	sessionService SessionManager
}

func NewUserHandler(usvc UserService, sm SessionManager) *UserHandler {
	return &UserHandler{
		userService:    usvc,
		sessionService: sm,
	}
}

func (h *UserHandler) respondWithToken(c *gin.Context, user *models.User, statusCode int) {
	token, err := h.sessionService.Issue(c.Request.Context(), user.ID)
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}

	loginData := dto.LoginResponse{
		SessionToken: token,
		User:         dto.NewUserResponse(user),
	}
	c.JSON(statusCode, dto.Success(loginData))
}

func (h *UserHandler) SignUp(c *gin.Context) {
	var req dto.SignupRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		appErr := dto.FilterBindError(err)
		c.JSON(dto.GetStatusCode(appErr), dto.Fail(appErr))
		return
	}

	if err := req.Validate(); err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}

	user, err := h.userService.Register(c.Request.Context(), req.Username, req.Email, req.Password)
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}

	h.respondWithToken(c, user, http.StatusCreated)
}

func (h *UserHandler) Login(c *gin.Context) {
	var req dto.LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		appErr := dto.FilterBindError(err)
		c.JSON(dto.GetStatusCode(appErr), dto.Fail(appErr))
		return
	}

	if err := req.Validate(); err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}

	user, err := h.userService.Login(c.Request.Context(), req.Email, req.Password)
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}

	h.respondWithToken(c, user, http.StatusOK)
}

func (h *UserHandler) GetMe(c *gin.Context) {
	auth, err := GetAuthContext(c)
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}

	user, err := h.userService.ToMyPage(c.Request.Context(), auth.UserID)
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}

	c.JSON(http.StatusOK, dto.Success(dto.NewUserResponse(user)))
}

func (h *UserHandler) Logout(c *gin.Context) {
	auth, err := GetAuthContext(c)
	if err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}
	if err := h.sessionService.Revoke(c.Request.Context(), auth.SessionID); err != nil {
		c.JSON(dto.GetStatusCode(err), dto.Fail(err))
		return
	}

	c.JSON(http.StatusOK, dto.SuccessMsg("ログアウトしました"))
}
</file>

<file path="README.md">
AITA - 高性能ソーシャルメディア・バックエンドプラットフォーム

AITAは、Go (Golang) で構築された、高並列・スケーラブルなSNSバックエンドのプロトタイプです。大規模なユーザー利用シーンを想定し、高速な認証、リアルタイムな情報配信、高度な全文検索の実装に焦点を当てています。

開発状況 (Development Status)

このプロジェクトは現在、フェーズ 1（コア機能の実装）を完了し、フェーズ2（パフォーマンス最適化）に移行しています。

フェーズ 1 (完了): ユーザー認証システム、データベース基盤の構築。ユーザー作成と認証のユニットテストと結合テスト作成

フェーズ 2 (進行中): Redisによる非同期処理、ツイート投稿機能の実装。

フェーズ 3 (予定): Elasticsearchによる検索エンジンの統合。

技術スタック

言語: Go 1.21+

Webフレームワーク: Gin Gonic

データベース: PostgreSQL (sqlxによる効率的なマッピング)

キャッシュ / メッセージキュー: Redis (Session管理、Redis Streams予定)

検索エンジン: Elasticsearch (導入予定)

インフラ: Docker & Docker Compose

認証: Bcryptハッシュパスワード + 独自Session Token

主な機能

実装済み (Implemented)

セッション認証システム:
標準的なBcryptによるパスワード暗号化に加え、セッションベースの認可処理を実装。

クリーンアーキテクチャ:
cmd/, internal/ をベースとしたディレクトリ構成を採用。レイヤードアーキテクチャにより疎結合を確保。

開発予定 (Upcoming)

高並列アーキテクチャ (Write Fan-out):
Redis Streamsを利用した非同期タスク処理により、タイムライン配信を高速化。

高度な全文検索:
Elasticsearchを統合し、投稿内容の高速検索を提供。

プロジェクト構成

.
├── cmd
│   └── api/           #　メインプログラム (main.go)
├── internal/
│   ├── api/           #　HTTPハンドラー, ルーティング, ミドルウェア
│   ├── configuaration #　設定情報の読み込み (env, yaml)
│   ├── contextkeys    #　コンテキストキー定義
│   ├── db/            #　ストレージ実装 (Postgres/Redis/ES)
│   ├── dto/           #  Data Transfer Object。リクエスト/レスポンスの構造体と変換処理。業務エラーコードとHTTPステータスのマッピング。
│   ├── errcode/       #  エラー定義。
│   ├── models/        #　データモデル定義
│   ├── pkg/
│   │    ├── crypto    #　暗号化関連。パスワードのハッシュ化やsha256でtokenの生成・検証
│   │    ├── testutils #　ユニットテストの補助関数（ヘルパー）
│   │    └── utils     #  汎用関数
│   └── service        #  テートデータベース作成
├── scripts
│   └── init-db        #  DB環境構築用スクリプト（Docker起動など）
├── migrations/        #　SQLマイグレーションファイル
└── tests/             #　結合テスト (＊作成中＊)


今後のロードマップ

[x] ユーザー登録・ログインAPIの実装。

[x] データベースマイグレーションツールの導入。

[x] DB層のトークン機能とユーザー機能のユニットテスト

[x] ツイート投稿機能の実装。

[ ] Redisによるタイムライン（Feed）のキャッシュ最適化。

[ ] Elasticsearchを用いた投稿内容の全文検索。

[ ] Google Cloud Storage (GCS) を利用した画像アップロード。
</file>

<file path="cmd/api/main.go">
package main

import (
	"aita/internal/api"
	"aita/internal/configuration"
	"aita/internal/db"
	"aita/internal/pkg/crypto"
	"aita/internal/service"
	"log"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
	"golang.org/x/crypto/bcrypt"
)


func main() {
	config := configuration.LoadConfig()
	database, err:= sqlx.Connect("postgres",config.DBConnStr)
	if err!= nil {
		log.Fatal("データベースに接続できません",err)
	}
	defer database.Close()
	log.Printf("データベースへの接続に成功しました")
	
	hasher := crypto.NewBcryptHasher(bcrypt.DefaultCost)
	tokenmanager := crypto.NewTokenManager()
	userStore := db.NewPostgresUserStore(database)
	sessionStore := db.NewPostgresSessionStore(database)
	tweetStore := db.NewPostgresTweetStore(database)
	userService := service.NewUserService(userStore, hasher)
	sessionService := service.NewSessionService(sessionStore, userService, tokenmanager)
	tweetService := service.NewTweetService(tweetStore)
	userHandler := api.NewUserHandler(userService, sessionService)
	tweetHandler := api.NewTweetHandler(tweetService)

	router := api.SetupRouter(userHandler, tweetHandler, sessionService)


	log.Printf("サーバーが起動し、ポート%sで待機中です",config.ServerAddress)
	if err :=router.Run(config.ServerAddress); err != nil{
		log.Fatal("サーバーの起動に失敗しました",err)
	}
}
</file>

<file path="internal/models/tweet.go">
package models

import(
	"time"
)

type Tweet struct{
	ID            int64        `db:"id"`
	UserID        int64		   `db:"user_id"`
	Content       string       `db:"content"`
	ImageURL     *string       `db:"image_url"`
	CreatedAt     time.Time    `db:"created_at"` 
	UpdatedAt     time.Time    `db:"updated_at"`
	IsEdited      bool         `db:"is_edited"`
}





func(t *Tweet) CanBeUpdated() bool {
	if t == nil {
		return false
	}

	duration := time.Now().UTC().Sub(t.CreatedAt.UTC())
	
	return duration <= editWindow
}
</file>

</files>
